"use strict";function Starbase(){let starbase={};function Memstore(){let onEvent,store={},data={};const clone=src=>{let target={};if("string"==typeof src)return target=src.toString();for(var prop in src instanceof Array&&(target=[]),src)src[prop]&&"object"==typeof src[prop]?target[prop]=clone(src[prop]):target[prop]=src[prop];return target};let eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)};return store.onEvent=cb=>{onEvent=cb},store.put=async(key,value)=>{data[key]=clone(value);var e={event:"write",key:key,timestamp:Date.now()};return eventHandler(e),e},store.get=async key=>clone({key:key,value:data[key]}),store.del=async keys=>{let keyPaths=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(key=>{delete data[key]});var e={event:"delete",keys:keyPaths,timestamp:Date.now()};return eventHandler(e),e},store.list=async query=>{query=query||{};let items=[];for(var key in data)query.values?items.push({key:key,value:data[key]}):items.push(key);query.values?items.sort((a,b)=>a.key<b.key?-1:a.key>b.key?1:0):items.sort(),query.reverse&&items.reverse();let results=[];for(let i=0;i<items.length&&!(query.limit&&results.length>=query.limit);i++)query.gt||query.lt?(query.values&&(query.gt&&items[i].key<=query.gt||query.lt&&items[i].key>=query.lt||results.push(items[i])),query.values||query.gt&&items[i]<=query.gt||query.lt&&items[i]>=query.lt||results.push(items[i])):results.push(items[i]);return clone(results)},store.importDB=async items=>{items.forEach(item=>{data[item.key]=clone(item.value)});var e={event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};return eventHandler(e),e},store.exportDB=async()=>store.list({values:!0}),store.deleteDB=async()=>{data={};var e={event:"deleteDB",timestamp:Date.now()};return eventHandler(e),e},store}function Channels(db){let onEvent;const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},Projection=(doc,projection)=>{let result={};for(var k in doc)projection[k]&&("object"==typeof projection[k]?result[k]=Projection(doc[k],projection[k]):result[k]=doc[k]);return result},Filter=(doc,filter)=>{let filtered=!1;if("string"==typeof filter&&"string"==typeof doc){var found=(y=filter,data=doc,y=new RegExp(filter.split(" ").map(val=>"(?=.*"+val+")").join(""),"i"),data.match(y));return!doc||!found}var y,data,k;for(k in filter){if(!doc[k]){filtered=!0;break}if(typeof filter[k]!=typeof doc[k]){filtered=!0;break}if(typeof filter[k]==typeof doc[k]&&(filtered=Filter(doc[k],filter[k]),filtered))break}return filtered},ParsePath=key=>{let reqPath;reqPath=key?key.toString():"/";let parts=reqPath.toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/");var channel="/"+parts.slice(0,-1).join("/"),slash="/"!=channel?"/":"";return{path:channel+slash+(key=parts.slice(-1)[0]),channel:channel,key:key,slash:slash,dsPath:"!"+channel+"!"+key}},Channel=(db,requestPath)=>{let parsedPath=ParsePath(requestPath).path;return{channel:()=>parsedPath,put:data=>Put(db,parsedPath,data),get:query=>Get(db,parsedPath,query),del:()=>((db,requestPath)=>new Promise((resolve,reject)=>{let{channel,key,slash}=ParsePath(requestPath);db.list({gt:"!"+channel+slash+key+"!",lt:"!"+channel+slash+key+"/￿/"}).then(results=>{results.unshift("!"+channel+"!"+key),db.del(results).then(deleted=>{var e=deleted.keys.map(val=>val.replace(/^\!/,"").replace(/\!/g,"/").replace(/\/\//g,"/").replace(/\/\//g,"/")),e={event:deleted.event,paths:e,timestamp:deleted.timestamp};eventHandler(e),resolve(e)})})}))(db,parsedPath),list:query=>List(db,parsedPath,query),parse:(path=null)=>ParsePath((path||parsedPath).toString()),path:path=>{path=path||"/";let slash="";return"/"!==parsedPath&&(slash="/"),Channel(db,parsedPath+slash+path)}}},Put=(db,requestPath,data)=>new Promise((resolve,reject)=>{if(!data)return reject({code:400,message:"Data is required."});if(requestPath.match(/\!/))return reject({code:400,message:"Invalid Path. The exclamation point (!) is a reserved character."});let{channel,key,slash}=ParsePath(requestPath);db.put("!"+channel+"!"+key,data).then(result=>{let response={event:result.event,path:channel+slash+(key||""),channel:channel,key:key||"",timestamp:result.timestamp};if("/"===channel&&(!key||""===key))return eventHandler(response),resolve(response);Get(db,channel).then(found=>{eventHandler(response),resolve(response)}).catch(err=>{Put(db,channel,{}).then(written=>{eventHandler(response),resolve(response)}).catch(reject)})}).catch(reject)}),Get=(db,requestPath,query)=>new Promise((resolve,reject)=>{let{channel,key,slash}=ParsePath(requestPath);db.get("!"+channel+"!"+key).then(response=>{if(!response.value)return reject({code:404,message:"Not Found"});let result={path:channel+slash+key,channel:channel,key:key,data:response.value};query&&query.projection&&"object"==typeof query.projection&&(result=Projection(result,query.projection)),query&&query.children?List(db,result.path,query.children).then(children=>{children&&children.data?result.children=children.data:result.children=[],resolve(result)}):resolve(result)}).catch(reject)}),List=(db,requestPath="/",query={})=>new Promise((resolve,reject)=>{query&&"object"==typeof query||(query={});let channel=requestPath.toString(),slash="";"/"!==channel&&(slash="/",channel="/"+channel.replace(/^\//,"").replace(/\/$/,""));var gt="!"+channel+"!"+(query.gt||"");let lt="!"+channel+"!"+(query.lt||"￿");query.deep&&(lt="!"+channel+slash+"￿"),db.list({gt:gt,lt:lt,reverse:query.reverse||!1,values:query.values||!1,limit:query.limit||null}).then(data=>{let last=null;data=data.map(val=>{var channel=(val="object"!=typeof val?{key:val}:val).key.replace(/^\!/,"").split("!")[0],key=val.key.replace(/^\!/,"").split("!")[1]||"/";let slash="";"/"!==channel&&(slash="/");let result={path:channel+slash+key,channel:channel,key:key};return last=result.key,val.value&&(result.data=val.value),query.projection&&"object"==typeof query.projection&&(result=Projection(result,query.projection)),result}).filter(val=>!(query.values&&val.data&&query.filter&&"object"==typeof query.filter&&Filter(val.data,query.filter)));let cursor=null;last&&(cursor={},query.limit&&(cursor.limit=parseInt(query.limit)),query.reverse?(cursor.reverse=!0,cursor.lt=last):(cursor.reverse=!1,cursor.gt=last),query.values&&(cursor.values=!0),query.filter&&(cursor.filter=query.filter),query.projection&&(cursor.projection=query.projection)),resolve({data:data,cursor:cursor})})});let channel=Channel(db,"/");return channel.onEvent=cb=>{onEvent=cb},channel.datastore=db,channel}function theRules(rules=[],body={},kit={}){return new Promise((resolve,reject)=>{let method=body.method||null,path=(body.path||"/").toString(),tests=[];if((rules=rules&&"object"==typeof rules&&!rules.forEach?[rules]:rules).forEach(rule=>{if(rule.path){var match=((rulePath,testPath)=>{let rule=(rulePath||"").toString().replace(/^\/|\/$/g,"").split("/"),test=(testPath||"").toString().replace(/^\/|\/$/g,"").split("/");if(rule.length!==test.length)return null;let params={};for(let x=0;x<rule.length;x++)if(rule[x]!==test[x]){if(":"!==rule[x].substring(0,1)){params=null;break}params[rule[x].substring(1,rule[x].length)]=test[x]}return params})(rule.path,path);if(match&&rule.rules&&rule.rules[method]){let cb;rule.methods&&rule.methods[method]&&"function"==typeof rule.methods[method]&&(cb=rule.methods[method]),tests.push({test:rule.rules[method],params:match,method:cb})}}}),0<tests.length){let promises=[];tests.forEach(test=>{promises.push(test.test(body,kit,test.params))}),Promise.all(promises).then(results=>{let ok=!1;for(let x=0;x<results.length;x++)if(results[x]){ok=tests[x];break}if(!ok||!ok.method)return ok&&!ok.method?reject({code:400,message:"Missing Methods."}):ok?void 0:reject({code:400,message:"Permission Denied"});resolve(ok.method(body,kit,ok.params))}).catch(err=>err&&err.message?reject(err):void reject({code:400,message:"Permission Denied - "+err.toString()}))}else reject({code:400,message:"Missing Permissions"})})}function Cryptic(webCrypto,encoder,decoder){let crypto=webCrypto;"undefined"!=typeof window&&(crypto=window.crypto||webCrypto);let TextEncoder=encoder,TextDecoder=decoder;"undefined"!=typeof window&&(TextEncoder=window.TextEncoder,TextDecoder=window.TextDecoder);const toHex=byteArray=>Array.from(new Uint8Array(byteArray)).map(val=>("0"+val.toString(16)).slice(-2)).join(""),encode=byteArray=>btoa(Array.from(new Uint8Array(byteArray)).map(val=>String.fromCharCode(val)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,""),decode=str=>new Uint8Array(atob(str.replace(/\_/g,"/").replace(/\-/g,"+")).split("").map(val=>val.charCodeAt(0))),fromText=string=>(new TextEncoder).encode(string),toText=byteArray=>(new TextDecoder).decode(byteArray),random=size=>crypto.getRandomValues(new Uint8Array(size));var ecdsaSign=async(key,msg,curve="P-256",hashAlg="SHA-256")=>{var sig=msg.toString(),signKey=await crypto.subtle.importKey("pkcs8",decode(key),{name:"ECDSA",namedCurve:curve},!1,["sign"]),sig=await crypto.subtle.sign({name:"ECDSA",hash:hashAlg},signKey,fromText(sig));return encode(sig)},ecdsaVerify=async(pub,sig,msg,curve="P-256",hashAlg="SHA-256")=>{var message=msg.toString(),verifyKey=await crypto.subtle.importKey("spki",decode(pub),{name:"ECDSA",namedCurve:curve},!1,["verify"]);return crypto.subtle.verify({name:"ECDSA",hash:hashAlg},verifyKey,decode(sig),fromText(message))};const hmacSign=async(bits,msg,hashAlg="SHA-256")=>{var sig=msg.toString(),hmacKey=await crypto.subtle.importKey("raw",bits,{name:"HMAC",hash:hashAlg},!1,["sign"]),sig=await crypto.subtle.sign({name:"HMAC",hash:hashAlg},hmacKey,fromText(sig));return encode(sig)},pbkdf2=async(bits,salt,iterations=1,size=256,hashAlg="SHA-256")=>{var result=await crypto.subtle.importKey("raw",bits,{name:"PBKDF2"},!1,["deriveBits"]),result=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:iterations,hash:hashAlg},result,size);return encode(result)},encrypt=async(plaintext,bits,AD=null)=>{var key=await crypto.subtle.importKey("raw",bits,{name:"AES-GCM"},!1,["encrypt"]),iv=random(12),cipher=fromText(plaintext),cipher=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv,additionalData:AD||fromText("")},key,cipher);return encode(iv)+"."+encode(cipher)},decrypt=async(ciphertext="",bits,AD=null)=>{var key=await crypto.subtle.importKey("raw",bits,{name:"AES-GCM"},!1,["decrypt"]),iv=decode(ciphertext.split(".")[0]),decrypted=decode(ciphertext.split(".")[1]),decrypted=await crypto.subtle.decrypt({name:"AES-GCM",iv:iv,additionalData:AD||fromText("")},key,decrypted).catch(err=>{throw{message:"Failed to decrypt message.",error:err}});return toText(decrypted)};return{combine:(bitsA=[],bitsB=[])=>{let A=bitsA,B=bitsB;"string"==typeof bitsA&&(A=decode(bitsA)),"string"==typeof bitsB&&(B=decode(bitsB));var a=new Uint8Array(A),b=new Uint8Array(B);let c=new Uint8Array(a.length+b.length);return c.set(a),c.set(b,a.length),c},createECDH:async(curve="P-256")=>{var key=await crypto.subtle.generateKey({name:"ECDH",namedCurve:curve},!0,["deriveBits"]),pub=await crypto.subtle.exportKey("spki",key.publicKey),key=await crypto.subtle.exportKey("pkcs8",key.privateKey);return{pub:encode(pub),key:encode(key)}},createECDSA:async(curve="P-256")=>{var key=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:curve},!0,["sign","verify"]),pub=await crypto.subtle.exportKey("spki",key.publicKey),key=await crypto.subtle.exportKey("pkcs8",key.privateKey);return{pub:encode(pub),key:encode(key)}},decode:decode,encode:encode,decrypt:decrypt,digest:async(bits,hashAlg="SHA-256")=>{var result=await crypto.subtle.digest({name:hashAlg},bits);return toHex(result)},ecdh:async(key,pub,curve="P-256",size=256)=>{var pubKey=await crypto.subtle.importKey("spki",decode(pub),{name:"ECDH",namedCurve:curve},!0,[]),shared=await crypto.subtle.importKey("pkcs8",decode(key),{name:"ECDH",namedCurve:curve},!0,["deriveBits"]),shared=await crypto.subtle.deriveBits({name:"ECDH",public:pubKey},shared,size);return encode(shared)},ecdsaSign:ecdsaSign,ecdsaVerify:ecdsaVerify,encode:encode,encrypt:encrypt,fromHex:str=>{let result=new Uint8Array(str.match(/.{0,2}/g).map(val=>parseInt(val,16)));return result.slice(0,result.length-1)},fromText:fromText,hmacSign:hmacSign,hmacVerify:async(bits,sig,msg,hashAlg="SHA-256")=>{var message=msg.toString(),verifyKey=await crypto.subtle.importKey("raw",bits,{name:"HMAC",hash:hashAlg},!1,["verify"]);return crypto.subtle.verify({name:"HMAC",hash:hashAlg},verifyKey,decode(sig),fromText(message))},kdf:async(bits,salt,info,size,hashAlg="SHA-256")=>{var key=await hmacSign(bits,toText(info));return pbkdf2(decode(key),salt,1,size,hashAlg)},passwordDecrypt:async(ciphertext="",password="")=>{var encrypted=toText(decode(ciphertext.split(".")[0])),keyBits=ciphertext.split(".")[1],keyBits=await pbkdf2(fromText(password),decode(keyBits),encrypted,256),encrypted=ciphertext.split(".").slice(2).join(".");return decrypt(encrypted,decode(keyBits))},passwordEncrypt:async(message,password="",iterations=1e5)=>{var salt=random(32),encrypted=await pbkdf2(fromText(password),salt,iterations,256),encrypted=await encrypt(message,decode(encrypted));return encode(fromText(iterations.toString()))+"."+encode(salt)+"."+encrypted},pbkdf2:pbkdf2,random:random,sign:ecdsaSign,toHex:toHex,toText:toText,verify:ecdsaVerify}}function CryptoDB(cryptic,datastore,memstore,secretKey,passwordKey,recoverOnLoad=!1,autosaveIndex=!1){let SECRET=null,PASSWORD=null,RECOVERY=null,indexName=null;const files=datastore,index=memstore;let loading=!1,loaded=!1,saving=!1,unsaved=!1;const hashPath=async path=>{var exists=await index.get(path);return exists&&exists.value?exists.value:await cryptic.hmacSign(SECRET,path)},Load=async()=>{if(loaded)return!0;if(loading)return new Promise((resolve,reject)=>{setTimeout(()=>{resolve(Load())},100)});loading=!0,SECRET=cryptic.decode(await cryptic.kdf(cryptic.fromText(secretKey),cryptic.fromText(passwordKey),cryptic.fromText("SECRET"),256)),PASSWORD=cryptic.decode(await cryptic.kdf(cryptic.fromText(passwordKey),cryptic.fromText(secretKey),cryptic.fromText("PASSWORD"),256)),RECOVERY=cryptic.decode(await cryptic.kdf(PASSWORD,SECRET,cryptic.fromText("RECOVERY"),256)),indexName=await cryptic.kdf(SECRET,PASSWORD,cryptic.fromText("INDEX"),256);var decrypted=(await files.get(indexName)).value;return decrypted&&(decrypted=await Decrypt(indexName,decrypted),await index.importDB(decrypted)),recoverOnLoad&&await recoverIndex(),loading=!1,loaded=!0},Encrypt=async(path,data)=>{var random=cryptic.random(32),encrypted=cryptic.combine(random,cryptic.fromText(path)),recovery=await cryptic.kdf(cryptic.combine(PASSWORD),encrypted,cryptic.fromText("ENCRYPT"),512),encrypted=await cryptic.decode(recovery).slice(0,32),recovery=await cryptic.decode(recovery).slice(32,64),encrypted=await cryptic.encrypt(JSON.stringify(data),encrypted,recovery),recovery=await cryptic.kdf(RECOVERY,random,cryptic.fromText("RECOVER"),256),recovery=await cryptic.encrypt(path,cryptic.decode(recovery));return cryptic.encode(random)+"."+encrypted+"."+recovery},Decrypt=async(path,payload)=>{var decrypted=payload.split(".")[0],encrypted=payload.split(".").slice(1).join("."),key=cryptic.combine(decrypted,cryptic.fromText(path)),decrypted=await cryptic.kdf(cryptic.combine(PASSWORD),key,cryptic.fromText("ENCRYPT"),512),key=await cryptic.decode(decrypted).slice(0,32),decrypted=await cryptic.decode(decrypted).slice(32,64),decrypted=await cryptic.decrypt(encrypted,key,decrypted);return JSON.parse(decrypted)},Put=async(path,data)=>{loaded||await Load();var hash=await hashPath(path),encrypted=await Encrypt(path,data);return await files.put(hash,encrypted),await index.put(path,hash),await save(),{event:"write",timestamp:Date.now(),key:path}},List=async(query={})=>{loaded||await Load();let body=Object.assign({},query);body.values=!0;let list=await index.list(body);if(query.values){let promises=[];for(let i=0;i<list.length;i++)promises.push(Get(list[i].key));return Promise.all(promises)}return list.map(file=>file.key)},Get=async path=>{loaded||await Load();let hash=await hashPath(path),encrypted=(await files.get(hash)).value,decrypted=null;return encrypted&&(decrypted=await Decrypt(path,encrypted)),{key:path,value:decrypted}},saveIndex=async(force=!1)=>saving&&!force?unsaved=!0:(unsaved=!1,saving=!0,Encrypt(indexName,await index.exportDB()).then(encryptedFS=>files.put(indexName,encryptedFS).then(async ok=>(saving=!1,!unsaved||save())))),save=async()=>!autosaveIndex||saveIndex(),importIndex=async indexData=>{let promises=[];for(let i=0;i<indexData.length;i++)promises.push(hashPath(indexData[i]).then(result=>({key:indexData[i],value:result})));var results=await Promise.all(promises);return await index.importDB(results),await save(),!0},recoverIndex=async()=>{let items=await datastore.list({values:!0}),recovered=[];for(let i=0;i<items.length;i++){var parts,path;items[i].value&&"string"==typeof items[i].value&&5===items[i].value.split(".").length&&(path=(parts=items[i].value.split("."))[0],path=await cryptic.kdf(RECOVERY,cryptic.decode(path),cryptic.fromText("RECOVER"),256),(path=await cryptic.decrypt(parts[3]+"."+parts[4],cryptic.decode(path)).catch(err=>null))&&items[i].key!==path&&recovered.push(path))}return importIndex(recovered)};return Load(),{put:Put,get:Get,del:async paths=>{loaded||await Load();let keyPaths=paths;"string"==typeof paths&&(keyPaths=[paths]);let promises=[];for(let i=0;i<keyPaths.length;i++)promises.push((async()=>{var hash=await hashPath(keyPaths[i]);await files.del(hash),await index.del(keyPaths[i])})());return await Promise.all(promises),await save(),{event:"delete",timestamp:Date.now(),keys:keyPaths}},list:List,importDB:async data=>{loaded||await Load();let paths=[];for(let i=0;i<data.length;i++)paths.push(data[i].key),await Put(data[i].key,data[i].value);return await save(),{event:"importDB",timestamp:Date.now(),keys:paths}},exportDB:async()=>(loaded||await Load(),List({values:!0})),deleteDB:async()=>{var deleted=await files.deleteDB();return await index.deleteDB(),loaded=!1,Date.now(),deleted},importIndex:importIndex,exportIndex:async()=>(loaded||await Load(),index.list()),saveIndex:saveIndex,deleteIndex:async()=>(await files.del(indexName),await index.deleteDB(),!0),recoverIndex:recoverIndex,onEvent:datastore.onEvent,hashPath:hashPath,raw:datastore}}function Encryption(cryptic){if(!cryptic)throw"An instance of Starbase Cryptic is require.";async function rootKDF(rk,dh){var ratchet=await cryptic.kdf(cryptic.decode(dh),cryptic.decode(rk),cryptic.fromText("ROOT"),512);return[cryptic.encode(cryptic.decode(ratchet).slice(0,32)),cryptic.encode(cryptic.decode(ratchet).slice(32))]}async function chainKDF(ck){var mk=await cryptic.hmacSign(cryptic.decode(ck),"");return[await cryptic.hmacSign(cryptic.decode(ck),""),mk]}async function skipMessageKeys(state,until,maxSkip){if(state.Nr+maxSkip<until)return Promise.reject({message:"Too many skipped messages!"});if(state.CKr)for(;state.Nr<until;){var mk=null;[state.CKr,mk]=await chainKDF(state.CKr),state.MKSKIPPED[state.DHr]||(state.MKSKIPPED[state.DHr]={}),state.MKSKIPPED[state.DHr][state.Nr]=mk,state.Nr+=1}}function cloneState(src){let target={};if("string"==typeof src)return target=src.toString();for(var prop in src instanceof Array&&(target=[]),src)src[prop]&&"object"==typeof src[prop]?target[prop]=cloneState(src[prop]):target[prop]=src[prop];return target}function Session(sessionData){let sessionState=cloneState(sessionData),session={to:()=>cloneState(sessionData).user,send:async message=>{let state=cloneState(sessionState.state),payload=await async function(state,msg,AD,init){var mk=null;[state.CKs,mk]=await chainKDF(state.CKs);var header={dh:state.DHs.pub,pn:state.PN,n:state.Ns};state.Ns+=1;let AEAD=await cryptic.kdf(cryptic.combine(cryptic.decode(AD),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("AEAD"),256),KEY=await cryptic.kdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),encrypted={header:header,ciphertext:await cryptic.encrypt(JSON.stringify(msg),cryptic.decode(KEY),cryptic.decode(AEAD))};return init&&(encrypted.init=cloneState(init)),encrypted}(state,message,sessionState.AD||null,sessionState.init||null);return payload.to=sessionData.user.toString(),sessionState.state=cloneState(state),payload}};return session.read=async payload=>{var state=cloneState(sessionState.state),msg=await async function(state,msgPayload={},AD,maxSkip=10){var{header,ciphertext}=msgPayload,plaintext=await cryptic.kdf(cryptic.combine(cryptic.decode(AD),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("AEAD"),256),KEY=await async function(state,header,ciphertext,AEAD){if(state.MKSKIPPED[header.dh]&&state.MKSKIPPED[header.dh][header.n]){var plaintext=state.MKSKIPPED[header.dh][header.n],plaintext=await cryptic.kdf(cryptic.combine(cryptic.decode(plaintext),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),plaintext=await cryptic.decrypt(ciphertext,cryptic.decode(plaintext),cryptic.decode(AEAD)).catch(err=>null);return plaintext?(delete state.MKSKIPPED[header.dh][header.n],{header:header,plaintext:plaintext}):null}}(state,header,ciphertext,plaintext||null);return KEY||(header.dh!==state.DHr&&(await skipMessageKeys(state,header.pn,maxSkip),await async function(state,header){state.PN=state.Ns,state.Ns=0,state.Nr=0,state.DHr=header.dh;var dh2=await cryptic.ecdh(state.DHs.key,state.DHr);[state.RK,state.CKr]=await rootKDF(state.RK,dh2),state.DHs=await cryptic.createECDH();dh2=await cryptic.ecdh(state.DHs.key,state.DHr);return[state.RK,state.CKs]=await rootKDF(state.RK,dh2),!0}(state,header)),await skipMessageKeys(state,header.n,maxSkip),KEY=null,[state.CKr,KEY]=await chainKDF(state.CKr),state.Nr+=1,KEY=await cryptic.kdf(cryptic.combine(cryptic.decode(KEY),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),plaintext=await cryptic.decrypt(ciphertext,cryptic.decode(KEY),cryptic.decode(plaintext)).catch(err=>{throw{error:"failed to decrypt"}}),delete state.init,{header:header,plaintext:JSON.parse(plaintext)})}(state,payload,sessionState.AD||null);sessionState.init&&delete sessionState.init;msg={header:payload.header,plaintext:msg.plaintext,from:session.to()};return sessionState.state=cloneState(state),msg},session.save=()=>{let backup={state:cloneState(sessionState.state)};return sessionState.init&&(backup.init=cloneState(sessionState.init)),sessionState.user&&(backup.user=cloneState(sessionState.user)),sessionState.AD&&(backup.AD=cloneState(sessionState.AD)),backup},session}function User(userData){let userState=cloneState(userData),user={};return user.createOPK=async()=>{var secret=await cryptic.createECDH();return{card:{user:userState.pub,opk:secret.pub},secret:secret}},user.sealEnvelope=async(to,msg)=>async function(user,to,message){var ek=await cryptic.createECDH(),msgkey=await cryptic.ecdh(ek.key,to),ciphertext=await cryptic.kdf(cryptic.decode(msgkey),new Uint8Array(32),cryptic.fromText("SEAL"),512),seal=cryptic.decode(ciphertext).slice(0,32),msgkey=cryptic.decode(ciphertext).slice(32,64),ciphertext=cryptic.combine(cryptic.decode(ek.pub),cryptic.decode(to)),seal=await cryptic.encrypt(user.pub,seal,ciphertext),ciphertext=await cryptic.ecdh(user.key,to),ciphertext=await cryptic.kdf(cryptic.decode(ciphertext),msgkey,cryptic.fromText("MESSAGE"),256),msgkey=cryptic.decode(ciphertext),ciphertext=cryptic.combine(cryptic.decode(user.pub),cryptic.decode(to)),ciphertext=await cryptic.encrypt(JSON.stringify(message),msgkey,ciphertext);return{type:"envelope",to:to,ek:ek.pub,seal:seal,ciphertext:ciphertext}}(userState,to,msg),user.openEnvelope=async env=>async function(user,envelope){var msgkey=await cryptic.ecdh(user.key,envelope.ek),decrypted=await cryptic.kdf(cryptic.decode(msgkey),new Uint8Array(32),cryptic.fromText("SEAL"),512),from=cryptic.decode(decrypted).slice(0,32),msgkey=cryptic.decode(decrypted).slice(32,64),decrypted=cryptic.combine(cryptic.decode(envelope.ek),cryptic.decode(user.pub)),from=await cryptic.decrypt(envelope.seal,from,decrypted),decrypted=await cryptic.ecdh(user.key,from),decrypted=await cryptic.kdf(cryptic.decode(decrypted),msgkey,cryptic.fromText("MESSAGE"),256),msgkey=cryptic.decode(decrypted),decrypted=cryptic.combine(cryptic.decode(from),cryptic.decode(user.pub)),decrypted=await cryptic.decrypt(envelope.ciphertext,msgkey,decrypted);return{type:"envelope",to:envelope.to,from:from,plaintext:JSON.parse(decrypted)}}(userState,env),user.createSession=async card=>{let session=await async function(user,card){var init=await cryptic.createECDH(),dh1=await cryptic.ecdh(user.key,card.opk),AD=await cryptic.ecdh(init.key,card.user),sk=await cryptic.ecdh(init.key,card.opk),AD=cryptic.combine(cryptic.combine(cryptic.decode(dh1),cryptic.decode(AD)),cryptic.decode(sk)),sk=await cryptic.kdf(AD,new Uint8Array(32),cryptic.fromText("SESSION"),256),AD=cryptic.encode(cryptic.combine(cryptic.decode(user.pub),cryptic.decode(card.user))),init={type:"init",to:card.user,from:user.pub,epk:init.pub,opk:card.opk};return{type:"session",user:card.user,sk:sk,AD:AD,init:init}}(userState,card);return session.state=await async function(session){let state={};state.DHs=await cryptic.createECDH(),state.DHr=session.init.opk;var dh=await cryptic.ecdh(state.DHs.key,state.DHr);return[state.RK,state.CKs]=await rootKDF(session.sk,dh),state.CKr=null,state.Ns=0,state.Nr=0,state.PN=0,state.MKSKIPPED={},state}(session),delete session.sk,Session(session)},user.openSession=async(init,secretOPK)=>{let session=await async function(user,opk,init){var dh1=await cryptic.ecdh(opk.key,init.from),AD=await cryptic.ecdh(user.key,init.epk),sk=await cryptic.ecdh(opk.key,init.epk),AD=cryptic.combine(cryptic.combine(cryptic.decode(dh1),cryptic.decode(AD)),cryptic.decode(sk)),sk=await cryptic.kdf(AD,new Uint8Array(32),cryptic.fromText("SESSION"),256),AD=cryptic.encode(cryptic.combine(cryptic.decode(init.from),cryptic.decode(user.pub)));return{type:"session",user:init.from,sk:sk,AD:AD}}(userState,secretOPK,init);return session.state=await async function(session){let state={};return state.DHs=secretOPK,state.DHr=null,state.RK=session.sk,state.CKs=null,state.CKr=null,state.Ns=0,state.Nr=0,state.PN=0,state.MKSKIPPED={},state}(session),delete session.sk,Session(session)},user.loadSession=async session=>Session(session),user.save=()=>cloneState(userState),user.getID=()=>cloneState(userState).pub,user}let cynops={};return cynops.cloneState=cloneState,cynops.cryptic=cryptic,cynops.createUser=async()=>User(await cryptic.createECDH()),cynops.loadUser=async userData=>User(userData),cynops}function Topics(){let topics={},ids=0;return{on:(topic,callback)=>{let id=(ids++).toString();return id=id,topics[topic]||(topics[topic]={}),topics[topic][id.toString()]=callback,{id:id,unsubscribe:()=>((topic,id)=>(topics[topic]&&delete topics[topic][id.toString()],!0))(topic,id)}},to:(topic,message)=>{if(topics[topic]){var sub,timestamp=Date.now();for(sub in topics[topic])"function"==typeof topics[topic][sub]&&topics[topic][sub]({topic:topic,message:message,timestamp:timestamp});return!0}return!1}}}return"undefined"!=typeof module&&module&&module.exports&&(module.exports=Memstore),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Channels),"undefined"!=typeof module&&module&&module.exports&&(module.exports=theRules),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Cryptic),"undefined"!=typeof module&&module&&module.exports&&(module.exports=CryptoDB),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Encryption),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Topics),starbase.Database=function(dbName){window.indexedDB||(window.indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB),window.IDBTransaction||(window.IDBTransaction=window.IDBTransaction||window.webkitIDBTransaction||window.msIDBTransaction||{READ_WRITE:"readwrite"}),window.IDBKeyRange||(window.IDBKeyRange=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange),dbName=dbName||"test";let db,onEvent;const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},close=async()=>(db&&(db.close(),db=null),!0),open=async()=>new Promise((resolve,reject)=>{if(db)return resolve(db);let open=indexedDB.open(dbName,1);open.onerror=e=>{reject({code:400,message:err.message||err.toString()||"Error!"})},open.onupgradeneeded=e=>{db=e.target.result,db.createObjectStore(dbName,{keyPath:"key"})},open.onsuccess=e=>{db=e.target.result,resolve(db)}}),list=query=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readonly").objectStore(dbName),results=[];var gt=(query=query&&"object"==typeof query?query:{}).gt||"\0",lt=query.lt||"￿";let limit;query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let req=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);req.onsuccess=()=>{let cursor=req.result;var result;!limit&&cursor||results.length<limit&&cursor?(result={},result=query.values?{key:cursor.value.key,value:cursor.value.value}:cursor.key,results.push(result),cursor.continue()):resolve(results)},req.onerror=req.onblocked=err=>{reject({code:400,message:"Error deleting database. "+err.toString()})}});return{put:(key,value)=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName),req=store.put({value:value,key:key});req.onsuccess=()=>{var e={db:dbName,event:"write",key:key,timestamp:Date.now()};eventHandler(e),resolve(e)},req.onerror=req.onblocked=err=>{reject({code:400,message:err.message||err.toString()||"Error!"})}}),get:key=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readonly").objectStore(dbName),req=store.get(key);req.onsuccess=e=>{var result=req.result;let value=null;result&&result.value&&(value=result.value),resolve({key:key,value:value})},req.onerror=req.onblocked=err=>{reject({code:400,message:err.message||err.toString()||"Error!"})}}),del:(keys=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName),keyPaths=[];if(!keys)return reject({code:400,message:"A key or an array of keys is required."});keyPaths="string"==typeof keys?[keys]:keys;let ops=[];keyPaths.forEach(path=>{ops.push({type:"del",key:path})});for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);store.transaction.oncomplete=()=>{var e={db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()};eventHandler(e),resolve(e)},store.transaction.onerror=err=>{reject({code:400,message:err.message||err.toString()||"Error!"})}}),list:list,deleteDB:()=>new Promise(async(resolve,reject)=>{await close();let req=indexedDB.deleteDatabase(dbName);req.onsuccess=function(){var e={db:dbName,event:"deleteDB",timestamp:Date.now()};eventHandler(e),resolve(e)},req.onerror=req.onblocked=e=>{reject({code:400,message:"Error deleting database. "+e.toString()})}}),exportDB:async()=>list({values:!0}),importDB:(items=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName);store.transaction.oncomplete=()=>{var e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};eventHandler(e),resolve(e)},store.onerror=err=>{reject({code:400,message:"Error importing database. "+err.toString()})};for(let x=0;x<items.length;x++)await store.put({key:items[x].key,value:items[x].value})}),onEvent:cb=>{onEvent=cb},close:close}},starbase.Memstore=Memstore,starbase.Channels=Channels,starbase.Client=function(serverPath){const ParsePath=requestPath=>{let reqPath,parts=(reqPath=requestPath?requestPath.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),channel="/"+parts.slice(0,-1).join("/"),key=parts.slice(-1)[0],slash="/"!=channel?"/":"";return{path:channel+slash+key,channel:channel,key:key,slash:slash,dsPath:"!"+channel+"!"+key}};let token=null,tokenHandler=null;const request=req=>new Promise(async(resolve,reject)=>{tokenHandler&&"function"==typeof tokenHandler&&(token=await tokenHandler());let body={};body.path=req.path||null,body.method=req.method||null,body.data=req.data||null,body.token=req.token||token||null,fetch(serverPath,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(body)}).then(async response=>{var result=await response.json();return(399<response.status?reject:resolve)(result)}).catch(err=>reject({code:500,message:err.message||err.toString()||"Error!"}))}),setToken=newToken=>(token=newToken,!0),Channel=requestPath=>{let parsedPath=ParsePath(requestPath).path;return{channel:()=>parsedPath,setToken:token=>{setToken(token)},setTokenHandler:cb=>{(cb=>tokenHandler=cb)(cb)},request:req=>request({method:req.method||null,path:req.path||parsedPath,data:req.data||null,token:req.token||null}),put:data=>((path,data)=>request({method:"put",path:path,data:data}))(parsedPath,data),get:query=>((path,query)=>request({method:"get",path:path,data:query}))(parsedPath,query),del:()=>(path=>request({method:"del",path:path}))(parsedPath),list:query=>((path,data)=>request({method:"list",path:path,data:data}))(parsedPath,query),parse:(path=null)=>ParsePath((path||parsedPath).toString()),path:path=>{path=path||"/";let slash="";return"/"!==parsedPath&&(slash="/"),Channel(parsedPath+slash+path)}}};return Channel("/")},starbase.Socket=function(server){let stateHandler,messageHandler,errorHandler,ws=null,closed=!1;const ERROR=e=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(e),console.error(e)},stateChange=state=>{stateHandler&&"function"==typeof stateHandler&&stateHandler(state)},onopen=e=>{stateChange("connected"),closed=!1},onclose=e=>{stateChange("disconnected"),closed||ERROR("disconnected.")},onmessage=msg=>{if(messageHandler&&"function"==typeof messageHandler)try{msg=JSON.parse(msg.data),messageHandler(msg)}catch(e){}},onerror=err=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(err)};let socket={getState:()=>!(!ws||1!==ws.readyState)};return socket.connect=socket.open=()=>{ws&&1===ws.readyState?ERROR("Already connected."):server?((ws=new WebSocket(server)).onopen=onopen,ws.onmessage=onmessage,ws.onclose=onclose,ws.onerror=onerror):ERROR("No server provided.")},socket.send=message=>{ws&&1===ws.readyState?ws.send(JSON.stringify(message),err=>{err?ERROR(err.toString()):console.log("Message Sent")}):ERROR("Not Connected")},socket.close=()=>{closed=!0,ws&&1===ws.readyState?ws.close():ERROR("Not Connected")},socket.onMessage=handler=>{messageHandler=handler},socket.onState=cb=>{stateHandler=cb},socket.onError=cb=>{errorHandler=cb},socket.setServer=socketURL=>{server=socketURL},socket},starbase.Realtime=function(sock,auth=null){let onError=null,onConnected=null,onDisconnected=null,onWhoami=null,onWhois=null,onUsers=null,onJoin=null,onLeave=null,onMessage=null,onRooms=null,onRoom=null,onChat=null,onAuth=null,onAll=null,callbacks={},ids=0;return sock.onState(s=>{"connected"===s&&(onConnected&&"function"==typeof onConnected&&onConnected({type:"connected"}),onAll&&"function"==typeof onAll&&onAll({type:"connected"})),"disconnected"===s&&(onDisconnected&&"function"==typeof onDisconnected&&onDisconnected({type:"disconnected"}),onAll&&"function"==typeof onAll&&onAll({type:"disconnected"}))}),sock.onError(err=>{onError&&"function"==typeof onError&&onError({error:err}),onAll&&"function"==typeof onAll&&onAll({error:err})}),sock.onMessage(async m=>{m.msgID&&callbacks[m.msgID]&&(m.error?callbacks[m.msgID].reject(m):callbacks[m.msgID].resolve(m)),"whoami"===m.type&&onWhoami&&"function"==typeof onWhoami&&onWhoami(m),"whois"===m.type&&onWhois&&"function"==typeof onWhois&&onWhois(m),"users"===m.type&&onUsers&&"function"==typeof onUsers&&onUsers(m),"rooms"===m.type&&onRooms&&"function"==typeof onRooms&&onRooms(m),"room"===m.type&&onRoom&&"function"==typeof onRoom&&onRoom(m),"message"===m.type&&onMessage&&"function"==typeof onMessage&&onMessage(m),"chat"===m.type&&onChat&&"function"==typeof onChat&&onChat(m),"join"===m.type&&onJoin&&"function"==typeof onJoin&&onJoin(m),"leave"===m.type&&onLeave&&"function"==typeof onLeave&&onLeave(m),"auth"===m.type&&onAuth&&"function"==typeof onAuth&&onAuth(m),onAll&&"function"==typeof onAll&&onAll(m)}),{onWhoami:cb=>{onWhoami=cb},onWhois:cb=>{onWhois=cb},onUsers:cb=>{onUsers=cb},onJoin:cb=>{onJoin=cb},onLeave:cb=>{onLeave=cb},onRoom:cb=>{onRoom=cb},onRooms:cb=>{onRooms=cb},onChat:cb=>{onChat=cb},onMessage:cb=>{onMessage=cb},onAuth:cb=>{onAuth=cb},onAll:cb=>{onAll=cb},onConnected:cb=>{onConnected=cb},onDisconnected:cb=>{onDisconnected=cb},onError:cb=>{onError=cb},connect:()=>{sock.connect()},close:()=>{sock.close()},whoami:()=>{let msgID=ids++;return sock.send({msgID:msgID,type:"whoami"}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},whois:(username=null,id=null)=>{let msgID=ids++;return id=id&&id.toString(),sock.send({msgID:msgID,type:"whois",username:username,id:id}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},join:room=>{let msgID=ids++;return sock.send({msgID:msgID,type:"join",room:room}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},leave:room=>{let msgID=ids++;return sock.send({msgID:msgID,type:"leave",room:room}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},chat:(room,message)=>{let msgID=ids++;return sock.send({msgID:msgID,type:"chat",room:room.toString(),chat:message}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},message:(to,message)=>{let msgID=ids++;return sock.send({msgID:msgID,type:"message",to:to.toString(),message:message}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},users:()=>{let msgID=ids++;return sock.send({msgID:msgID,type:"users"}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},rooms:()=>{let msgID=ids++;return sock.send({msgID:msgID,type:"rooms"}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},room:room=>{let msgID=ids++;return sock.send({msgID:msgID,type:"room",room:room}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},auth:async()=>{let msgID=ids++;return auth&&sock.send({msgID:msgID,type:"auth",token:await auth.getToken()}),new Promise((resolve,reject)=>{callbacks[msgID]={resolve:resolve,reject:reject}})},sock:sock}},starbase.theRules=theRules,starbase.Auth=function(api=null,localDB=null,options={}){if(!api)throw"Starbase Channels API Client is missing.";if(!localDB)throw"Starbase Channels Database is missing.";let db=localDB,request=(method,credentials)=>api.path("/").request({method:method,data:credentials}),tokenPath=((options=!options||"object"!=typeof options?{}:options).parentChannel||"/auth/token").toString(),stateHandler=null,authToken=null,user=null,stateChange=async token=>{token=token||null,authToken=token,db&&await db.path(tokenPath).put({token:authToken}),user=authToken&&authToken.user?authToken.user:null,auth.user=user,stateHandler&&"function"==typeof stateHandler&&stateHandler(authToken)},auth={user:null,getToken:()=>(async()=>new Promise(async(resolve,reject)=>{var storedToken;return authToken||!db||(storedToken=await db.path(tokenPath).get().then(result=>result.data).catch(err=>null))&&storedToken.token&&(authToken=storedToken.token,stateChange(authToken)),authToken?authToken.accessExpires<Date.now()?authToken.refreshExpires>Date.now()?void request("refreshToken",authToken).then(result=>(stateChange(result),resolve(result.accessToken))).catch(err=>(err.code&&err.code<499&&stateChange(null),reject(err))):(stateChange(null),reject({code:400,message:"Invalid or expired token."})):resolve(authToken.accessToken):resolve(null)}))(),onStateChange:cb=>{stateHandler=cb,auth.getToken().catch(err=>{})},createUser:(username,password)=>new Promise((resolve,reject)=>{request("createUser",{username:username,password:password}).then(resolve).catch(reject)}),deleteUser:(username,password)=>new Promise((resolve,reject)=>{request("deleteUser",{username:username,password:password}).then(resolve).catch(reject)}),changePassword:(username,password,newPassword)=>new Promise((resolve,reject)=>{request("changePassword",{username:username,password:password,newPassword:newPassword}).then(resolve).catch(reject)}),signIn:(username,password)=>new Promise((resolve,reject)=>{request("signIn",{username:username,password:password}).then(token=>{stateChange(token),resolve(token)}).catch(err=>{reject(err)})}),signOut:()=>new Promise((resolve,reject)=>{stateChange(null),resolve({message:"Signed out."})})};return auth},starbase.Admin=function(api,auth){if(!api)throw"Starbase Channels API Client object is missing.";if(!auth)throw"Starbase Authentication object is missing.";return api.setTokenHandler(auth.getToken),api},starbase.Profiles=function(api=null,auth=null){if(!api)throw"The Starbase Channels API client is missing";if(!auth)throw"The Starbase Authentication client is missing";return{getProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).get()},deleteProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).del()},updateProfile:async function(username,profile){return api.setToken(await auth.getToken()),api.path(username).put(profile)},listProfiles:async function(query={}){return query&&"object"==typeof query||((query={}).limit=10),(!query.limit||10<query.limit)&&(query.limit=10),api.setToken(await auth.getToken()),api.list(query)},auth:auth}},starbase.Files=function(url,auth){return{meta:async(folder="",id)=>fetch(url+"/meta",{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({id:id,folder:folder,token:await auth.getToken()})}).then(response=>response.json()),remove:async(folder="",id)=>fetch(url+"/remove",{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({id:id,folder:folder,token:await auth.getToken()})}).then(response=>response.json()),list:async(folder="",query={})=>fetch(url+"/list",{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({query:query,folder:folder,token:await auth.getToken()})}).then(response=>response.json()),upload:async(folder="",file)=>{let form=new FormData;return form.append("token",await auth.getToken()),form.append("folder",folder),form.append("file",file),fetch(url+"/upload",{method:"POST",body:form}).then(response=>response.json())},uploader:async(folder="",container)=>{const el=document.createElement("div"),info=document.createElement("p"),fileLabel=document.createElement("label");fileLabel.innerText="Select File";const fileInput=document.createElement("input");fileInput.classList.add("hidden"),fileLabel.appendChild(fileInput),fileLabel.classList.add("button"),fileInput.type="file",fileInput.multiple=!0,el.appendChild(fileLabel),el.appendChild(info),container.append(el),fileInput.onchange=async e=>{let promises=[];if(e.target.files){info.innerText="Uploading "+e.target.files.length+" file(s)...";for(let i=0;i<e.target.files.length;i++)promises.push(files.upload(folder,e.target.files[i]));await Promise.all(promises).then(results=>{info.innerText=JSON.stringify(results,null,4)}).catch(err=>{info.innerText=err.message||err.toString()||"Error"})}}}}},starbase.PWA=function(){return{app:(swURL,onInstallReady=null,onUpdateReady=null,onRefreshReady=null,cacheName="resources")=>{navigator.serviceWorker.register(swURL);const getServiceWorker=async()=>navigator.serviceWorker.getRegistration();return window.addEventListener("beforeinstallprompt",e=>{onInstallReady&&"function"==typeof onInstallReady&&onInstallReady(async cb=>{e.prompt(),e.userChoice.then(result=>{cb&&"function"==typeof cb&&cb(result)})})}),navigator.serviceWorker.addEventListener("message",e=>{e.data.msg&&"refresh"===e.data.msg&&e.data&&e.data.url&&location.href===e.data.url&&onRefreshReady&&"function"==typeof onRefreshReady&&onRefreshReady(!0)}),navigator.serviceWorker.getRegistration().then(reg=>{reg&&reg.addEventListener("updatefound",()=>{onUpdateReady&&"function"==typeof onUpdateReady&&onUpdateReady(!0)})}),{getServiceWorker:getServiceWorker,RESET:async()=>{caches.delete(cacheName),await getServiceWorker().then(reg=>{reg.unregister().then(()=>{location.reload()}).catch(err=>{location.reload()})})}}},sw:(resources,offlineURL=null,cacheName="resources")=>(offlineURL&&!resources.includes(offlineURL)&&resources.push(offlineURL),self.addEventListener("install",async e=>{console.log("Installing Service Worker..."),await caches.delete(cacheName);let cache=await caches.open(cacheName);return await cache.addAll(resources),self.skipWaiting()}),self.addEventListener("activate",async e=>{console.log("Service Worker Activated!")}),self.addEventListener("fetch",async e=>{"GET"===e.request.method&&e.respondWith((async()=>{let cache=await caches.open(cacheName),cached=await cache.match(e.request,{ignoreSearch:!0});return cached?(e.waitUntil((async request=>fetch(request).then(async response=>{if(200===response.status){let cache=await caches.open(cacheName),cached=await cache.match(request);if(cached&&response.headers.get("eTag")!==cached.headers.get("eTag")){var client;await cache.put(request,response.clone());for(client of await clients.matchAll())client.postMessage({msg:"refresh",url:request.url})}}}).catch(err=>{}))(e.request)),cached):fetch(e.request).then(async response=>(200===response.status&&await cache.put(e.request,response.clone()),response)).catch(err=>cache.match("/offline"))})())}),{})}},starbase.Cryptic=Cryptic,starbase.CryptoDB=CryptoDB,starbase.Encryption=Encryption,starbase.Messages=function(encryption,db,serverURL,userData=null,sock=null,push=null,options={}){let serverIDK=null,user=null,opk=null,parentChannel="/messages";options&&options.parentChannel&&"string"==typeof options.parentChannel&&(parentChannel=db.path(options.parentChannel).channel());const REQUEST=async(method,payload)=>fetch(serverURL+"/"+method,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(payload)}).then(async response=>{var result=await response.json();if(399<response.statusCode)throw result;return result}),resetContact=async userID=>(await db.path(parentChannel).path("/contacts").path(userID).path("session").del(),await db.path(parentChannel).path("/contacts").path(userID).path("stale").del(),await sendMessage(userID,{reset:!0},!0),{reset:!0}),loadUser=async()=>{var exists;return userData&&(user=await encryption.loadUser(userData).catch(err=>null)),user||(exists=await db.path(parentChannel).path("/user").get().catch(err=>null))&&(user=await encryption.loadUser(exists.data)),user?await loadOPK():(user=await encryption.createUser(),await loadOPK(),await sendOPK()),await db.path(parentChannel).path("/user").put(user.save()),user},loadOPK=async()=>{var opkData=await db.path(parentChannel).path("/user/opk").get().catch(err=>null);return opkData?(opk=opkData.data,opkData.data):updateOPK()},updateOPK=async()=>(opk=await user.createOPK(),await db.path(parentChannel).path("/user/opk").put(opk),opk),getServerIDK=()=>serverIDK,getToken=async type=>{var tokenData=await db.path(parentChannel).path("/token").path(user.getID()).get().then(result=>result.data).catch(err=>null);return tokenData&&tokenData.decoded&&tokenData.decoded.exp>parseInt(Date.now()/1e3)?(serverIDK=tokenData.serverIDK,tokenData[type+"Token"]):hello().then(result=>result[type+"Token"]||null).catch(err=>{throw{error:"Could not obtain a token from the server."}})},sendOPK=async()=>{user||await loadUser(userData);var sealed=await getToken("user");if(!sealed)return Promise.reject({error:"Invalid or expired token."});sealed=await user.sealEnvelope(getServerIDK(),{opk:opk.card.opk,token:sealed}),await REQUEST("opk",sealed)},getMessages=async(limit=100)=>{user||await loadUser(userData);var sealed=await getToken("user");if(!sealed)return Promise.reject({error:"Invalid or expired token."});var subscriptionExists=await db.path(parentChannel).path("/push").get().catch(err=>null);let sub=null;subscriptionExists&&(sub=subscriptionExists.data.subscription.keys.auth),sealed=await user.sealEnvelope(getServerIDK(),{token:sealed,limit:parseInt(limit),sub:sub});let response=await REQUEST("messages",sealed);if(response){let msgs=[],ids=[];for(let i=0;i<response.data.length;i++){response.data[i].data.timestamp=new Date(parseInt(response.data[i].key.slice(3,16))).getTime();var msg=await(async env=>{let saved=null,opened=await user.openEnvelope(env);if(opened.plaintext&&opened.plaintext.init&&opened.plaintext.init.from&&opened.from!==opened.plaintext.init.from)return null;var stale=await db.path(parentChannel).path("/contacts").path(opened.from).get().catch(err=>null);if(stale&&stale.data.blocked)return null;stale=await db.path(parentChannel).path("/contacts").path(opened.from).path("session").get().catch(err=>null);if(stale){let session=await user.loadSession(stale.data),read=await session.read(opened.plaintext).catch(err=>null);return read?(read.timestamp=env.timestamp,saved=await saveReadMessage(opened.from,read,env.protocol||!1),env.protocol||await db.path(parentChannel).path("/contacts").path(opened.from).path("session").put(session.save())):(opened.plaintext.init?(env.protocol||await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").put(session.save()),session=await user.openSession(opened.plaintext.init,opk.secret),opk.used=!0):(stale=await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").get().catch(err=>null))&&(env.protocol||await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").put(session.save()),session=await user.loadSession(stale.data)),read=await session.read(opened.plaintext).catch(err=>null),read&&(read.timestamp=env.timestamp,saved=await saveReadMessage(opened.from,read,env.protocol||!1),env.protocol||await db.path(parentChannel).path("/contacts").path(opened.from).path("session").put(session.save()))),saved}{let session=null;if(opened.plaintext.init)session=await user.openSession(opened.plaintext.init,opk.secret),opk.used=!0;else{let stale=await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").get().catch(err=>null);if(!stale)return await resetContact(opened.from).catch(err=>null),null;session=await user.loadSession(stale.data)}let read=await session.read(opened.plaintext).catch(err=>null);return read?(read.timestamp=env.timestamp,saved=await saveReadMessage(opened.from,read,env.protocol||!1),env.protocol||await db.path(parentChannel).path("/contacts").path(opened.from).path("session").put(session.save())):await resetContact(opened.from).catch(err=>null),saved}})(response.data[i].data,opk);ids.push(response.data[i].key),msg&&!msg.protocol&&msgs.push(msg)}return ids.length&&await(async(sealed=[])=>{user||await loadUser(userData);var token=await getToken("user");return token?(sealed=await user.sealEnvelope(getServerIDK(),{token:token,ids:sealed}),REQUEST("acknowledge",sealed)):Promise.reject({error:"Invalid or expired token."})})(ids),0<response.data.length&&response.data.length<parseInt(limit)&&opk.used&&await updateOPK(),await sendOPK(),msgs.length&&gotMessagesHandler&&"function"==typeof gotMessagesHandler&&gotMessagesHandler(!0),msgs}return Promise.reject({code:400,message:"Failed to open envelope."})};let saveHandler=null,gotMessagesHandler=null;const saveReadMessage=async(contact,save,protocol=!1)=>{var msg={to:user.getID(),from:contact,plaintext:save.plaintext,timestamp:save.timestamp,status:"received"};return protocol?(msg.plaintext&&msg.plaintext.reset&&(console.log("resetting session..."),await db.path(parentChannel).path("/contacts").path(contact).path("session").del(),await db.path(parentChannel).path("/contacts").path(contact).path("stale").del()),null):(save=await db.path(parentChannel).path("/contacts").path(contact).path("messages").path(save.timestamp).put(msg),saveHandler&&"function"==typeof saveHandler&&saveHandler({path:save.path,msg:msg}),msg)},sendMessage=async(to,msg,protocol=!1)=>{user||await loadUser(userData);var sent=await getToken("anon"),exists=await db.path(parentChannel).path("/contacts").path(to).path("session").get().catch(err=>null);let session=null;exists?session=await user.loadSession(exists.data):(send=await(async id=>{user||await loadUser(userData);var token=await getToken("anon");return REQUEST("card",{token:token,msg:{id:id}}).catch(err=>null)})(to),session=await user.createSession(send),await db.path(parentChannel).path("/contacts").path(to).path("session").put(session.save()));var send=await session.send(msg);let sealed=await user.sealEnvelope(to,send);return protocol&&(sealed.protocol=!0),(sent=await REQUEST("send",{token:sent,msg:sealed}).catch(err=>null))?(await db.path(parentChannel).path("/contacts").path(to).path("session").put(session.save()),await db.path(parentChannel).path("/contacts").path(to).path("messages").path(sent.timestamp).put({to:to,from:user.getID(),plaintext:msg,timestamp:sent.timestamp,status:"sent"}),Promise.resolve(sent)):Promise.reject({code:400,message:"Failed to send message!"})},hello=async()=>{user||await loadUser(userData);var anonToken=await user.createOPK(),decoded=await REQUEST("hello",anonToken.card),opened=await user.openEnvelope(decoded);let userToken=opened.plaintext.userToken;return anonToken=opened.plaintext.anonToken,decoded=JSON.parse(cryptic.toText(cryptic.decode(userToken.split(".")[1]))),serverIDK=opened.from,await db.path(parentChannel).path("/token").path(user.getID()).put({anonToken:anonToken,userToken:userToken,decoded:decoded,serverIDK:opened.from}),{anonToken:anonToken,userToken:userToken,decoded:decoded}};return{getMessages:getMessages,sendMessage:sendMessage,getID:()=>user.getID(),getToken:getToken,listContacts:async query=>db.path(parentChannel).path("/contacts").list(query),updateContact:async(userID,profile={},unread=!1)=>{var exists=await db.path(parentChannel).path("/contacts").path(userID).get().catch(err=>null);let updated=profile||{};return updated.timestamp=Date.now(),updated.unread=unread||!1,updated.userID=userID,exists&&exists.data&&(!updated.name&&exists.data.name&&(updated.name=exists.data.name),!updated.photo&&exists.data.photo&&(updated.photo=exists.data.photo)),db.path(parentChannel).path("/contacts").path(userID).put(updated)},resetContact:resetContact,deleteContact:async userID=>db.path(parentChannel).path("/contacts").path(userID).del(),listMessages:async(userID,query)=>db.path(parentChannel).path("/contacts").path(userID).path("messages").list(query),onSave:cb=>{saveHandler=cb},connect:async()=>{sock&&(sock.onError(console.log),sock.onState(async s=>{"connected"===s&&sock.send({id:user.getID(),token:await getToken("user")})}),sock.onMessage(async()=>{await getMessages()}),sock.getState()||sock.connect())},subscribe:async e=>push?push.getPermission().then(result=>"granted"===result).catch(err=>!1)?push.subscribe(serverURL+"/push/subscribe").then(async result=>db.path(parentChannel).path("/push").put({subscription:result.subscription}).then(saved=>({subscribed:!0}))):null:{supported:!1},unsubscribe:async e=>push?push.unsubscribe(serverURL+"/push/unsubscribe").then(async result=>db.path(parentChannel).path("/push").del().then(deleted=>({unsubscribed:!0}))):{supported:!1},getContact:async userID=>db.path(parentChannel).path("/contacts").path(userID).get().then(result=>result.data).catch(err=>null),isSubscribed:async()=>db.path(parentChannel).path("/push").get().then(result=>!0).catch(err=>!1),onGotMessages:cb=>{gotMessagesHandler=cb}}},starbase.Topics=Topics,starbase.Push=function(publicKey){return"object"!=typeof window?(()=>{let messageHandler,clickHandler;return self.addEventListener("push",async e=>{let data={};e.data&&(data=e.data.json());let openClients=await clients.matchAll();if(openClients){let bg=!0;openClients.forEach(client=>{"visible"===client.visibilityState&&(bg=!1),client.postMessage({type:"push",data:data})}),bg&&messageHandler&&"function"==typeof messageHandler&&messageHandler(data)}else messageHandler&&"function"==typeof messageHandler&&messageHandler(data)}),self.addEventListener("notificationclick",e=>{clickHandler&&"function"==typeof clickHandler&&clickHandler(e.notification),e.notification.close()}),{onMessage:cb=>{messageHandler=cb},onClick:cb=>{clickHandler=cb}}})():(publicKey=>{let messageHandler;return navigator.serviceWorker.addEventListener("message",e=>{messageHandler&&"function"==typeof messageHandler&&e.data&&e.data.type&&"push"===e.data.type&&messageHandler(e.data.data||"")}),{onMessage:cb=>{messageHandler=cb},subscribe:async(url=null,token=null)=>{if("!PushManager"in window||"!Notification"in window)throw{message:"This browser or device does not support push notifications."};var permission=await Notification.requestPermission();if(!permission||"granted"!==permission)throw{message:"Notifications permission is required to subscribe to push notifications."};let subscription=await(await navigator.serviceWorker.getRegistration()).pushManager.subscribe({userVisibleOnly:!0,applicationServerKey:new Uint8Array(atob(publicKey.replace(/\-/g,"+").replace(/\_/g,"/")).split("").map(val=>val.charCodeAt(0)))}).then(result=>result.toJSON()).catch(err=>{console.log(err)});return url?fetch(url,{method:"POST",body:JSON.stringify({subscription:subscription,token:token}),headers:{"content-type":"application/json"}}).then(response=>({message:"Push notifications are enabled.",subscribed:!0,subscription:subscription})).catch(err=>(console.log(err),err)):{message:"Push notifications are available. You are not yet subscribed to a remote service.",subscribed:!1,subscription:subscription}},unsubscribe:async(url=null,token=null)=>{let subscription=await(await navigator.serviceWorker.getRegistration()).pushManager.getSubscription();return subscription&&await subscription.unsubscribe(),url?fetch(url,{method:"POST",body:JSON.stringify({subscription:subscription,token:token}),headers:{"content-type":"application/json"}}).then(response=>({unsubscribe:!0})).catch(err=>(console.log(err),err)):{unsubscribe:!0}},getPermission:Notification.requestPermission}})(publicKey)},starbase.WEBRTC=function(configuration=null,polite=!1){const pc=new RTCPeerConnection(configuration||{iceServers:[{urls:["stun:stun1.l.google.com:19302","stun:stun2.l.google.com:19302"]}]});let sendHandler=null;const send=e=>{sendHandler&&"function"==typeof sendHandler&&sendHandler(e)};let errorHandler=null;const error=err=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(err)};let connectedHandler=null,disconnectedHandler=null,dataChannels={},dataChannelHandler=null,tracks={},trackHandler=null,makingOffer=!(pc.oniceconnectionstatechange=e=>{"connected"===e.target.iceConnectionState&&connectedHandler&&"function"==typeof connectedHandler&&connectedHandler({type:"connected"}),"disconnected"===e.target.iceConnectionState&&disconnectedHandler&&"function"==typeof disconnectedHandler&&disconnectedHandler({type:"disconnected"}),"failed"===e.target.iceConnectionState&&pc.restartIce()});pc.onnegotiationneeded=async()=>{try{makingOffer=!0;var offer=await pc.createOffer();await pc.setLocalDescription(offer).then().catch(error),send({description:pc.localDescription})}catch(err){error(err)}finally{makingOffer=!1}},pc.onicecandidate=({candidate})=>send({candidate:candidate}),pc.ondatachannel=e=>{dataChannelHandler&&"function"==typeof dataChannelHandler&&dataChannelHandler(e),dataChannels[e.channel.label]=e.channel};let ignoreOffer=!(pc.ontrack=e=>{trackHandler&&"function"==typeof trackHandler&&trackHandler(e),tracks[e.track.id]=e.track});return{peerConnection:pc,createDataChannel:(label=null,options={})=>{var dataChannel=pc.createDataChannel(label,options);return dataChannels[label]=dataChannel},addTrack:(track,stream)=>pc.addTrack(track,stream),listen:async({description,candidate})=>{try{if(description){var answer,offerCollision="offer"==description.type&&(makingOffer||"stable"!=pc.signalingState);if(ignoreOffer=!polite&&offerCollision)return;await pc.setRemoteDescription(description).then().catch(error),"offer"==description.type&&(answer=await pc.createAnswer(),await pc.setLocalDescription(answer).then().catch(error),send({description:pc.localDescription}))}else if(candidate)try{await pc.addIceCandidate(candidate).then().catch(error)}catch(err){if(!ignoreOffer)throw err}}catch(err){error(err)}},onSend:cb=>{sendHandler=cb},onError:cb=>{errorHandler=cb},onTrack:cb=>{trackHandler=cb},onDataChannel:cb=>{dataChannelHandler=cb},onConnected:cb=>{connectedHandler=cb},onDisconnected:cb=>{disconnectedHandler=cb},tracks:tracks,dataChannels:dataChannels,close:()=>{pc.close(),disconnectedHandler&&"function"==typeof disconnectedHandler&&disconnectedHandler({type:"disconnected"})}}},starbase.Pages=function(db,parentPath="pages",container=null,callback){const component=document.createElement("div");component.classList.add("component"),component.classList.add("editor");const list=document.createElement("select");list.placeholder="Documents:",component.appendChild(list);const documentsOption=document.createElement("option");documentsOption.value="Documents:",documentsOption.innerText="Documents:",list.appendChild(documentsOption);const path=document.createElement("input");path.value="",path.placeholder="Path:",component.appendChild(path);const title=document.createElement("input");title.value="",title.placeholder="Title:",component.appendChild(title);const description=document.createElement("input");description.value="",description.placeholder="Description:",component.appendChild(description);const pubdate=document.createElement("input");pubdate.value="",pubdate.placeholder="Publish Date:",component.appendChild(pubdate);const author=document.createElement("input");author.value="",author.placeholder="Author:",component.appendChild(author);const photo=document.createElement("input");photo.value="",photo.placeholder="Featured Photo:",component.appendChild(photo);const redirect=document.createElement("input");redirect.value="",redirect.placeholder="Redirect:",component.appendChild(redirect);const template=document.createElement("input");template.value="",template.placeholder="Template:",component.appendChild(template);const loadButton=document.createElement("button");loadButton.innerText="📂 Load",component.appendChild(loadButton);const deleteButton=document.createElement("button");deleteButton.innerText="🚫 Delete",component.appendChild(deleteButton);const saveButton=document.createElement("button");saveButton.innerText="💾 Save",component.appendChild(saveButton);const info=document.createElement("p");info.classList.add("info"),component.appendChild(info);const content=document.createElement("textarea");content.value="",content.placeholder="Content:",component.appendChild(content);const above=document.createElement("textarea");above.value="",above.placeholder="Above Content:",component.appendChild(above);const below=document.createElement("textarea");below.value="",below.placeholder="Below Content:",component.appendChild(below);let unsaved=!1,refreshing=!(above.onchange=above.onpaste=above.onkeyup=below.onchange=below.onpaste=below.onkeyup=content.onpaste=content.onchange=content.onkeyup=title.onpaste=title.onchange=title.onkeyup=description.onpaste=description.onchange=description.onkeyup=pubdate.onkeyup=pubdate.onchange=pubdate.onpaste=author.onkeyup=author.onchange=author.onpaste=photo.onchange=photo.onpaste=photo.onkeyup=redirect.onchange=redirect.onkeyup=redirect.onpaste=template.onchange=template.onkeyup=template.onpaste=path.onchange=path.onkeyup=path.onpaste=e=>{unsaved=!0});const refreshList=async()=>{if(refreshing)return null;refreshing=!0,list.innerHTML="";let firstOption=document.createElement("option");firstOption.innerText="Documents:",firstOption.value="",list.appendChild(firstOption);let docs=await db.path(parentPath).list({deep:!0});docs.data.forEach(doc=>{let option=document.createElement("option");option.value=db.parse(doc.path.replace(parentPath,"")).path,option.innerText=db.parse(doc.path.replace(parentPath,"")).path,list.appendChild(option)}),list.onchange=async e=>{path.value.toString(),path.value=list.value,await Load(e)||(path.value="")},refreshing=!1},handler=e=>{callback&&"function"==typeof callback&&callback(e)},Load=async e=>(e.preventDefault(),unsaved&&!confirm("Unsaved changes. Are you sure you want to continue?")?(list.value="",null):(unsaved=!1,content.value="",above.value="",below.value="",title.value="",redirect.value="",template.value="",description.value="",pubdate.value="",author.value="",photo.value="",["/","/pages","/templates","/functions"].includes(db.path(path.value).parse().path)?(info.innerText="This resource cannot be loaded in the editor.",null):db.path(parentPath).path(path.value).get().then(async result=>(info.innerText="Loaded",result.data.content&&(content.value=result.data.content),title.value=result.data.title||"",description.value=result.data.description||"",pubdate.value=result.data.pubdate||"",author.value=result.data.author||"",photo.value=result.data.photo||"",redirect.value=result.data.redirect||"",template.value=result.data.template||"",above.value=result.data.above||"",below.value=result.data.below||"",!(list.value=""))).catch(err=>{info.innerText=err.message||"Error",description.value="",pubdate.value="",author.value="",photo.value="",title.value="",content.value="",path.value=""})));loadButton.onclick=Load,saveButton.onclick=async e=>{if(e.preventDefault(),info.innerText="Saving...",["/","pages","/templates","/functions"].includes(db.path(path.value).parse().path))return info.innerText="This resource cannot be changed in the editor.",null;let data={};data.title=title.value||"",data.description=description.value||"",data.pubdate=pubdate.value||"",data.author=author.value||"",data.photo=photo.value||"",data.content=content.value||"",data.redirect=redirect.value||"",data.template=template.value||"",data.above=above.value||"",data.below=below.value||"",await db.path(parentPath).path(path.value).put(data).then(result=>{info.innerText="Saved",handler({type:"save",path:path.value}),unsaved=!1,refreshList()}).catch(err=>{info.innerText=err.message||"Error"})},deleteButton.onclick=async e=>(e.preventDefault(),["/","/pages","/menu","/templates","/functions"].includes(db.path(path.value).parse().path)?(info.innerText="This resource cannot be changed in the editor.",null):confirm("Do you really want to delete this?")?void db.path(parentPath).path(path.value).del().then(result=>{title.value="",description.value="",pubdate.value="",author.value="",photo.value="",content.value="",above.value="",below.value="",redirect.value="",template.value="",info.innerText="Deleted",path.value="",handler({type:"delete",path:path.value}),unsaved=!1,refreshList()}).catch(err=>{info.innerText=err.message||"Error"}):null);var hide=(doNotDisplay=!1)=>{component.classList.add("hidden"),doNotDisplay&&(component.style.display="none")};return hide(),container&&container.appendChild(component),{component:component,hide:hide,show:async(displayType=null)=>{component.classList.remove("hidden"),displayType&&(component.style.display=displayType.toString()),await refreshList()}}},starbase}