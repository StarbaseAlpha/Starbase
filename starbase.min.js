"use strict";function Starbase(){let starbase={};function memstore(){let onEvent,store={},data={},eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)};return store.onEvent=(cb=>{onEvent=cb}),store.put=(async(key,value)=>{data[key]=value;let e={event:"write",key:key,timestamp:Date.now()};return eventHandler(e),e}),store.get=(async key=>({key:key,value:data[key]})),store.del=(async keys=>{let keyPaths=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(key=>{delete data[key]});let e={event:"delete",keys:keyPaths,timestamp:Date.now()};return eventHandler(e),e}),store.list=(async query=>{query=query||{};let items=[];for(let key in data)query.values?items.push({key:key,value:data[key]}):items.push(key);query.values?items.sort((a,b)=>a.key<b.key?-1:a.key>b.key?1:0):items.sort(),query.reverse&&items.reverse();let results=[];for(let i=0;i<items.length&&!(query.limit&&results.length>=query.limit);i++)query.gt||query.lt?(query.values&&(query.gt&&items[i].key<=query.gt||query.lt&&items[i].key>=query.lt||results.push(items[i])),query.values||query.gt&&items[i]<=query.gt||query.lt&&items[i]>=query.lt||results.push(items[i])):results.push(items[i]);return results}),store.importDB=(async items=>{items.forEach(item=>{data[item.key]=item.value});let e={event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};return eventHandler(e),e}),store.exportDB=(async()=>store.list({values:!0})),store.deleteDB=(async()=>{data={};let e={event:"deleteDB",timestamp:Date.now()};return eventHandler(e),e}),store}function Channels(db){let onEvent;const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},ParsePath=requestPath=>{let reqPath,parts=(reqPath=requestPath?requestPath.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),channel="/"+parts.slice(0,-1).join("/"),key=parts.slice(-1)[0],slash="";return"/"!==channel&&(slash="/"),{path:channel+slash+key,channel:channel,key:key,slash:slash}},Channel=(db,requestPath)=>{let parsedPath=ParsePath(requestPath).path;return{channel:()=>parsedPath,put:data=>Put(db,parsedPath,data),get:()=>Get(db,parsedPath),del:()=>Del(db,parsedPath),list:query=>List(db,parsedPath,query),path:path=>{path||(path="/");let slash="";return"/"!==parsedPath&&(slash="/"),Channel(db,parsedPath+slash+path)}}},Put=(db,requestPath,data)=>new Promise((resolve,reject)=>{if(!data)return reject({code:400,message:"Data is required."});if(requestPath.match(/\!/))return reject({code:400,message:"Invalid Path. The exclamation point (!) is a reserved character."});let{path:path,channel:channel,key:key,slash:slash}=ParsePath(requestPath);db.put("!"+channel+"!"+key,data).then(result=>{let response={event:result.event,path:channel+slash+(key||""),channel:channel,key:key||"",timestamp:result.timestamp};if("/"===channel&&(!key||""===key))return eventHandler(response),resolve(response);Get(db,channel).then(found=>{eventHandler(response),resolve(response)}).catch(err=>{Put(db,channel,{}).then(written=>{eventHandler(response),resolve(response)}).catch(reject)})}).catch(reject)}),Get=(db,requestPath)=>new Promise((resolve,reject)=>{let{path:path,channel:channel,key:key,slash:slash}=ParsePath(requestPath);db.get("!"+channel+"!"+key).then(result=>{if(!result.value)return reject({code:404,message:"Not Found"});resolve({path:channel+slash+key,channel:channel,key:key,data:result.value})}).catch(reject)}),Del=(db,requestPath)=>new Promise((resolve,reject)=>{let{path:path,channel:channel,key:key,slash:slash}=ParsePath(requestPath);db.list({gt:"!"+channel+slash+key+"!",lt:"!"+channel+slash+key+"￿/"}).then(results=>{results.unshift("!"+channel+"!"+key),db.del(results).then(deleted=>{let paths=deleted.keys.map(val=>val.replace(/^\!/,"").replace(/\!/g,"/").replace(/\/\//g,"/").replace(/\/\//g,"/")),e={event:deleted.event,paths:paths,timestamp:deleted.timestamp};eventHandler(e),resolve(e)})})}),List=(db,requestPath="/",query={})=>new Promise((resolve,reject)=>{"object"!=typeof query&&(query={});let channel=requestPath.toString(),slash="";"/"!==channel&&(slash="/",channel="/"+channel.replace(/^\//,"").replace(/\/$/,""));let gt="!"+channel+"!"+(query.gt||""),lt="!"+channel+"!"+(query.lt||"￿");!!query.deep&&(lt="!"+channel+slash+"￿"),db.list({gt:gt,lt:lt,reverse:query.reverse||!1,values:query.values||!1,limit:query.limit||null}).then(results=>{let data=results.map(val=>{"object"!=typeof val&&(val={key:val});let channel=val.key.replace(/^\!/,"").split("!")[0],key=val.key.replace(/^\!/,"").split("!")[1]||"/",slash="";"/"!==channel&&(slash="/");let result={path:channel+slash+key,channel:channel,key:key};return val.value&&(result.data=val.value),result});resolve({data:data})})});let channel=Channel(db,"/");return channel.onEvent=(cb=>{onEvent=cb}),channel}function theRules(rules=[],request={},kit={}){return new Promise((resolve,reject)=>{let method=request.method||null,path=(request.path||"/").toString(),tests=[];if(rules&&"object"==typeof rules&&!rules.forEach&&(rules=[rules]),rules.forEach(rule=>{if(rule.path){let match=((rulePath,testPath)=>{let rule=(rulePath||"").toString().replace(/^\/|\/$/g,"").split("/"),test=(testPath||"").toString().replace(/^\/|\/$/g,"").split("/");if(rule.length!==test.length)return null;let params={};for(let x=0;x<rule.length;x++)if(rule[x]!==test[x]){if(":"!==rule[x].substring(0,1)){params=null;break}params[rule[x].substring(1,rule[x].length)]=test[x]}return params})(rule.path,path);if(match&&rule.rules&&rule.rules[method]){let cb;rule.methods&&rule.methods[method]&&"function"==typeof rule.methods[method]&&(cb=rule.methods[method]),tests.push({test:rule.rules[method],params:match,method:cb})}}}),tests.length>0){let promises=[];tests.forEach(test=>{promises.push(test.test(request,kit,test.params))}),Promise.all(promises).then(results=>{let ok=!1;for(let x=0;x<results.length;x++)if(results[x]){ok=tests[x];break}if(ok&&ok.method)resolve(ok.method(request,kit,ok.params));else{if(ok&&!ok.method)return reject({code:400,message:"Missing Methods."});if(!ok)return reject({code:400,message:"Permission Denied"})}}).catch(err=>{if(err&&err.message)return reject(err);reject({code:400,message:"Permission Denied - "+err.toString()})})}else reject({code:400,message:"Missing Permissions"})})}return"undefined"!=typeof module&&module&&module.exports&&(module.exports=memstore),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Channels),"undefined"!=typeof module&&module&&module.exports&&(module.exports=theRules),starbase.Database=function(dbName){let database={put:(dbName,key,data)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});if(!key)return reject({code:400,message:"A key is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite");tx.objectStore(dbName).put(data,key),tx.oncomplete=(()=>{resolve({db:dbName,event:"write",key:key,timestamp:Date.now()}),db.close()}),tx.onerror=(err=>{db.close(),reject(err)})})}),get:(dbName,key)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});if(!key)return reject({code:400,message:"A key is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readonly"),request=tx.objectStore(dbName).get(key);tx.oncomplete=(()=>{resolve({key:key,value:request.result}),db.close()}),tx.onerror=(err=>{db.close(),reject(err)})})}),del:(dbName,keys)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});if(!keys)return reject({code:400,message:"A key or an array of keys is required."});let db,keyPaths=[];keyPaths="string"==typeof keys?[keys]:keys;let open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite"),store=tx.objectStore(dbName);for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);tx.oncomplete=(()=>{resolve({db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()}),db.close()}),tx.onerror=(err=>{db.close(),reject(err)})})}),list:(dbName,query)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite"),store=tx.objectStore(dbName);query&&"object"==typeof query||(query={});let limit,results=[],gt=query.gt||"\0",lt=query.lt||"￿";query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let request=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);request.onsuccess=(()=>{let cursor=request.result;if(!limit&&cursor||results.length<limit&&cursor){let result={};query.values?(result.key=cursor.primaryKey,result.value=cursor.value):result=cursor.primaryKey,results.push(result),cursor.continue()}}),tx.oncomplete=(()=>{db.close(),resolve(results)}),tx.onerror=(err=>{db.close(),reject(err)})})}),deleteDB:dbName=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});let request=indexedDB.deleteDatabase(dbName);request.onsuccess=(()=>{let e={db:dbName,event:"deleteDB",timestamp:Date.now()};resolve(e)}),request.onerror=request.onblocked=(err=>{reject({code:400,message:"Error deleting database. "+err.toString()})})}),exportDB:dbName=>database.list(dbName,{values:!0}),importDB:(dbName,items)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite"),store=tx.objectStore(dbName);for(let x=0;x<items.length;x++)store.put(items[x].value,items[x].key);tx.oncomplete=(()=>{let e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};db.close(),resolve(e)}),tx.onerror=(err=>{db.close(),reject({code:400,message:"Error importing database. "+err.toString()})})})}),db:dbName=>{dbName||(dbName="test");let onEvent,db={onEvent:cb=>{onEvent=cb}},eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)};return db.put=((key,data)=>new Promise((resolve,reject)=>{database.put(dbName,key,data).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db.get=((key,data)=>database.get(dbName,key)),db.del=(keys=>new Promise((resolve,reject)=>{database.del(dbName,keys).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db.list=(query=>database.list(dbName,query)),db.deleteDB=(()=>new Promise((resolve,reject)=>{database.deleteDB(dbName).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db.exportDB=(()=>database.exportDB(dbName)),db.importDB=(data=>new Promise((resolve,reject)=>{database.importDB(dbName,data).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db}};return database.db(dbName)},starbase.memstore=memstore,starbase.Channels=Channels,starbase.ChannelsAPI=function(serverPath){let token=null;const request=req=>fetch(serverPath,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({token:token||req.token||"",method:req.method||"",path:req.path||"",data:req.data||{}})}).then(response=>response.json()),setToken=newToken=>(token=newToken,!0),Channel=requestPath=>{let parsedPath=(requestPath=>{let reqPath,parts=(reqPath=requestPath?requestPath.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),channel="/"+parts.slice(0,-1).join("/"),key=parts.slice(-1)[0],slash="";return"/"!==channel&&(slash="/"),{path:channel+slash+key,channel:channel,key:key,slash:slash}})(requestPath).path;return{channel:()=>parsedPath,setToken:token=>{setToken(token)},put:data=>((path,data)=>request({method:"put",path:path,data:data}))(parsedPath,data),get:()=>(path=>request({method:"get",path:path}))(parsedPath),del:()=>(path=>request({method:"del",path:path}))(parsedPath),list:query=>((path,data)=>request({method:"list",path:path,data:data}))(parsedPath,query),path:path=>{path||(path="/");let slash="";return"/"!==parsedPath&&(slash="/"),Channel(parsedPath+slash+path)}}};return Channel("/")},starbase.Socket=function(server,stateHandler,messageHandler,errorHandler){let ws=null,tries=0,closed=!1,ERROR=e=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(e),console.error(e)};const stateChange=function(state){stateHandler&&"function"==typeof stateHandler&&stateHandler(state)},onopen=function(e){stateChange("connected"),closed=!1,tries=0},connect=function(){ws&&1===ws.readyState?ERROR("Already Connected."):server?((ws=new WebSocket(server)).onopen=onopen,ws.onmessage=onmessage,ws.onclose=onclose,ws.onerror=onerror):ERROR("No Server Provided.")},onclose=function(e){stateChange("disconnected"),closed||(ERROR("disconnected."),tries<3?(tries++,stateChange("reconnecting"),setTimeout(connect,3e3)):(stateChange("disconnected"),ERROR("Failed to reconnect 3 times."),closed=!0))},onmessage=function(msg){if(messageHandler&&"function"==typeof messageHandler)try{msg=JSON.parse(msg.data),messageHandler(msg)}catch(e){}},onerror=function(err){errorHandler&&"function"==typeof errorHandler&&errorHandler(err)};let socket={getState:function(){return!(!ws||1!==ws.readyState)}};return socket.connect=socket.open=connect,socket.send=(message=>{ws&&1===ws.readyState?ws.send(JSON.stringify(message),err=>{err?ERROR(err.toString()):console.log("Message Sent")}):ERROR("Not Connected")}),socket.close=function(){closed=!0,ws&&1===ws.readyState?ws.close():ERROR("Not Connected")},socket.onMessage=(handler=>{handler&&"function"==typeof handler&&(messageHandler=handler)}),socket.onState=(handler=>{handler&&"function"==typeof handler&&(stateHandler=handler)}),socket.onError=(handler=>{handler&&"function"==typeof handler&&(errorHandler=handler)}),socket.setServer=(newserver=>{server=newserver}),socket},starbase.theRules=theRules,starbase.Encryption=function(){return{encrypt:async(message,options={})=>{if(!message||"string"!=typeof message)return Promise.reject({code:400,message:"Message must be a string."});if("object"!=typeof options)return Promise.reject({code:400,message:"Invalid options parameters."});let{password:password,passwordBits:passwordBits,iterations:iterations,hmacBits:hmacBits}=options;if(!password&&!passwordBits)return Promise.reject({code:400,message:"No password or passwordBits was provided."});let pass,rounds=iterations||5e5,iterationsHash=btoa(rounds.toString()).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),msg=(new TextEncoder).encode(message);password&&(pass=await crypto.subtle.importKey("raw",(new TextEncoder).encode(password),{name:"PBKDF2"},!1,["deriveBits"])),passwordBits&&(pass=await crypto.subtle.importKey("raw",new Uint8Array(passwordBits),{name:"PBKDF2"},!1,["deriveBits"]));let salt=crypto.getRandomValues(new Uint8Array(32)),saltHash=btoa(Array.from(new Uint8Array(salt)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),iv=crypto.getRandomValues(new Uint8Array(12)),ivHash=btoa(Array.from(new Uint8Array(iv)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),bits=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:rounds,hash:{name:"SHA-256"}},pass,512),aesBits=bits.slice(32,64),aesKey=await crypto.subtle.importKey("raw",aesBits,{name:"AES-GCM"},!1,["encrypt"]);hmacBits||(hmacBits=bits.slice(0,32));let hmacKey=await crypto.subtle.importKey("raw",hmacBits,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),enc=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv},aesKey,msg),encrypted=iterationsHash+"."+saltHash+"."+ivHash+"."+btoa(Array.from(new Uint8Array(enc)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),sigData=(new TextEncoder).encode(encrypted),signature=await crypto.subtle.sign({name:"HMAC"},hmacKey,sigData);return encrypted+"."+btoa(Array.from(new Uint8Array(signature)).map(val=>String.fromCharCode(val)).join("")).replace(/\=/g,"").replace(/\+/g,"-").replace(/\//g,"_")},decrypt:async(encrypted,options={})=>{if(!encrypted||"string"!=typeof encrypted)return Promise.reject({code:400,message:"Encrypted text must be a string."});if("object"!=typeof options)return Promise.reject({code:400,message:"Invalid options parameters."});let{password:password,passwordBits:passwordBits,hmacBits:hmacBits}=options;if(!password&&!passwordBits)return Promise.reject({code:400,message:"No password or passwordBits was provided."});let pass,parts=encrypted.split("."),rounds=parseInt(atob(parts[0])),salt=new Uint8Array(atob(parts[1].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0))),iv=new Uint8Array(atob(parts[2].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0))),enc=new Uint8Array(atob(parts[3].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0))),sig=new Uint8Array(atob(parts[4].replace(/-/g,"+").replace(/_/g,"/")).split("").map(val=>val.charCodeAt(0)));password&&(pass=await crypto.subtle.importKey("raw",(new TextEncoder).encode(password),{name:"PBKDF2"},!1,["deriveBits"])),passwordBits&&(pass=await crypto.subtle.importKey("raw",new Uint8Array(passwordBits),{name:"PBKDF2"},!1,["deriveBits"]));let bits=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:rounds,hash:{name:"SHA-256"}},pass,512),aesBits=bits.slice(32,64),aesKey=await crypto.subtle.importKey("raw",aesBits,{name:"AES-GCM"},!1,["decrypt"]);hmacBits||(hmacBits=bits.slice(0,32));let hmacKey=await crypto.subtle.importKey("raw",hmacBits,{name:"HMAC",hash:{name:"SHA-256"}},!1,["verify"]),sigData=(new TextEncoder).encode(encrypted.split(".").slice(0,4).join("."));if(!await crypto.subtle.verify({name:"HMAC"},hmacKey,sig,sigData))return Promise.reject({error:"Password or signature does not match."});let dec=await crypto.subtle.decrypt({name:"AES-GCM",iv:iv},aesKey,enc);return(new TextDecoder).decode(dec)}}},starbase.Auth=function(serverPath=null,dbPath=null){let request=(method,credentials)=>new Promise((resolve,reject)=>{fetch(serverPath,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({path:"/",method:method,data:credentials})}).then(response=>{response.json().then(result=>response.status>399?reject(result):resolve(result))})}),db=null,stateHandler=null,authToken=null,user=null;dbPath&&"function"==typeof Starbase&&(db=Starbase().Channels(Starbase().Database(dbPath)));let stateChange=async token=>{token||(token=null),authToken=token,db&&await db.path("/auth/token").put({token:authToken}),authToken&&authToken.user?(user=authToken.user,auth.user=user):(user=null,auth.user=user),stateHandler&&"function"==typeof stateHandler&&stateHandler(authToken)},auth={user:null,getToken:()=>(async()=>new Promise(async(resolve,reject)=>{if(!authToken&&db){let storedToken=await db.path("/auth/token").get().then(result=>result.data).catch(err=>null);storedToken&&storedToken.token&&(authToken=storedToken.token,stateChange(authToken))}return authToken?authToken.accessExpires<Date.now()?authToken.refreshExpires>Date.now()?void request("refreshToken",authToken).then(result=>(stateChange(result),resolve(result.accessToken))).catch(err=>(stateChange(null),reject(err))):(stateChange(null),reject({code:400,message:"Invalid or expired token."})):resolve(authToken.accessToken):reject({code:400,message:"Invalid or expired token."})}))(),onStateChange:cb=>{stateHandler=cb},createUser:(username,password)=>new Promise((resolve,reject)=>{request("createUser",{username:username,password:password}).then(resolve).catch(reject)}),deleteUser:(username,password)=>new Promise((resolve,reject)=>{request("deleteUser",{username:username,password:password}).then(resolve).catch(reject)}),changePassword:(username,password,newPassword)=>new Promise((resolve,reject)=>{request("changePassword",{username:username,password:password,newPassword:newPassword}).then(resolve).catch(reject)}),signIn:(username,password)=>new Promise((resolve,reject)=>{request("signIn",{username:username,password:password}).then(token=>{stateChange(token),resolve(token)}).catch(err=>{reject(err)})}),signOut:()=>new Promise((resolve,reject)=>{stateChange(null),resolve({message:"Signed out."})})};return db&&auth.getToken().catch(err=>{}),auth},starbase.Profiles=function(api=null,auth=null){if(!api)throw"The Starbase Channels API client is missing";if(!auth)throw"The Starbase Authentication client is missing";return{getProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).get()},deleteProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).del()},updateProfile:async function(username,profile){return api.setToken(await auth.getToken()),api.path(username).put(profile)},listProfiles:async function(query){return api.setToken(await auth.getToken()),api.list(query)},auth:auth}},starbase}