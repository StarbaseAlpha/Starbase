"use strict";function Starbase(){let starbase={};function Memstore(){let onEvent,store={},data={};const clone=src=>{let target={};src instanceof Array&&(target=[]);for(let prop in src)src[prop]&&"object"==typeof src[prop]?target[prop]=clone(src[prop]):target[prop]=src[prop];return target};let eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)};return store.onEvent=(cb=>{onEvent=cb}),store.put=(async(key,value)=>{data[key]=value;let e={event:"write",key:key,timestamp:Date.now()};return eventHandler(e),e}),store.get=(async key=>clone({key:key,value:data[key]})),store.del=(async keys=>{let keyPaths=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(key=>{delete data[key]});let e={event:"delete",keys:keyPaths,timestamp:Date.now()};return eventHandler(e),e}),store.list=(async query=>{query=query||{};let items=[];for(let key in data)query.values?items.push({key:key,value:data[key]}):items.push(key);query.values?items.sort((a,b)=>a.key<b.key?-1:a.key>b.key?1:0):items.sort(),query.reverse&&items.reverse();let results=[];for(let i=0;i<items.length&&!(query.limit&&results.length>=query.limit);i++)query.gt||query.lt?(query.values&&(query.gt&&items[i].key<=query.gt||query.lt&&items[i].key>=query.lt||results.push(items[i])),query.values||query.gt&&items[i]<=query.gt||query.lt&&items[i]>=query.lt||results.push(items[i])):results.push(items[i]);return clone(results)}),store.importDB=(async items=>{items.forEach(item=>{data[item.key]=item.value});let e={event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};return eventHandler(e),e}),store.exportDB=(async()=>store.list({values:!0})),store.deleteDB=(async()=>{data={};let e={event:"deleteDB",timestamp:Date.now()};return eventHandler(e),e}),store}function Channels(e){let t;const l=e=>{t&&"function"==typeof t&&t(e)},r=(e,t)=>{let l={};for(let n in e)t[n]&&("object"==typeof t[n]?l[n]=r(e[n],t[n]):l[n]=e[n]);return l},n=(e,t)=>{let l=!1;if("string"==typeof t&&"string"==typeof e){let l=new RegExp(t,"ig");return!e||!e.match(l)}for(let r in t){if(!e[r]){l=!0;break}if(typeof t[r]!=typeof e[r]){l=!0;break}if(typeof t[r]==typeof e[r]&&(l=n(e[r],t[r])))break}return l},a=e=>{let t,l=(t=e?e.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),r="/"+l.slice(0,-1).join("/"),n=l.slice(-1)[0],a="";return"/"!==r&&(a="/"),{path:r+a+n,channel:r,key:n,slash:a}},i=(e,t)=>{let l=a(t).path;return{channel:()=>l,put:t=>o(e,l,t),get:t=>p(e,l,t),del:()=>c(e,l),list:t=>s(e,l,t),parse:(e=null)=>a((e||l).toString()),path:t=>{t||(t="/");let r="";return"/"!==l&&(r="/"),i(e,l+r+t)}}},o=(e,t,r)=>new Promise((n,i)=>{if(!r)return i({code:400,message:"Data is required."});if(t.match(/\!/))return i({code:400,message:"Invalid Path. The exclamation point (!) is a reserved character."});let{path:c,channel:s,key:h,slash:u}=a(t);e.put("!"+s+"!"+h,r).then(t=>{let r={event:t.event,path:s+u+(h||""),channel:s,key:h||"",timestamp:t.timestamp};if("/"===s&&(!h||""===h))return l(r),n(r);p(e,s).then(e=>{l(r),n(r)}).catch(t=>{o(e,s,{}).then(e=>{l(r),n(r)}).catch(i)})}).catch(i)}),p=(e,t,l)=>new Promise((n,i)=>{let{path:o,channel:p,key:c,slash:h}=a(t);e.get("!"+p+"!"+c).then(t=>{if(!t.value)return i({code:404,message:"Not Found"});let a={path:p+h+c,channel:p,key:c,data:t.value};l&&l.projection&&"object"==typeof l.projection&&(a=r(a,l.projection)),l&&l.children?s(e,a.path,l.children).then(e=>{e&&e.data?a.children=e.data:a.children=[],n(a)}):n(a)}).catch(i)}),c=(e,t)=>new Promise((r,n)=>{let{path:i,channel:o,key:p,slash:c}=a(t);e.list({gt:"!"+o+c+p+"!",lt:"!"+o+c+p+"￿/"}).then(t=>{t.unshift("!"+o+"!"+p),e.del(t).then(e=>{let t=e.keys.map(e=>e.replace(/^\!/,"").replace(/\!/g,"/").replace(/\/\//g,"/").replace(/\/\//g,"/")),n={event:e.event,paths:t,timestamp:e.timestamp};l(n),r(n)})})}),s=(e,t="/",l={})=>new Promise((a,i)=>{l&&"object"==typeof l||(l={});let o=t.toString(),p="";"/"!==o&&(p="/",o="/"+o.replace(/^\//,"").replace(/\/$/,""));let c="!"+o+"!"+(l.gt||""),s="!"+o+"!"+(l.lt||"￿");!!l.deep&&(s="!"+o+p+"￿"),e.list({gt:c,lt:s,reverse:l.reverse||!1,values:l.values||!1,limit:l.limit||null}).then(e=>{let t=null,i=e.map(e=>{"object"!=typeof e&&(e={key:e});let n=e.key.replace(/^\!/,"").split("!")[0],a=e.key.replace(/^\!/,"").split("!")[1]||"/",i="";"/"!==n&&(i="/");let o={path:n+i+a,channel:n,key:a};return t=o.key,e.value&&(o.data=e.value),l.projection&&"object"==typeof l.projection&&(o=r(o,l.projection)),o}).filter(e=>!(l.values&&e.data&&l.filter&&"object"==typeof l.filter&&n(e.data,l.filter))),o=null;t&&(o={},l.limit&&(o.limit=parseInt(l.limit)),l.reverse?(o.reverse=!0,o.lt=t):(o.reverse=!1,o.gt=t),l.values&&(o.values=!0),l.filter&&(o.filter=l.filter),l.projection&&(o.projection=l.projection)),a({data:i,cursor:o})})});let h=i(e,"/");return h.onEvent=(e=>{t=e}),h}function theRules(rules=[],request={},kit={}){return new Promise((resolve,reject)=>{let method=request.method||null,path=(request.path||"/").toString(),tests=[];if(rules&&"object"==typeof rules&&!rules.forEach&&(rules=[rules]),rules.forEach(rule=>{if(rule.path){let match=((rulePath,testPath)=>{let rule=(rulePath||"").toString().replace(/^\/|\/$/g,"").split("/"),test=(testPath||"").toString().replace(/^\/|\/$/g,"").split("/");if(rule.length!==test.length)return null;let params={};for(let x=0;x<rule.length;x++)if(rule[x]!==test[x]){if(":"!==rule[x].substring(0,1)){params=null;break}params[rule[x].substring(1,rule[x].length)]=test[x]}return params})(rule.path,path);if(match&&rule.rules&&rule.rules[method]){let cb;rule.methods&&rule.methods[method]&&"function"==typeof rule.methods[method]&&(cb=rule.methods[method]),tests.push({test:rule.rules[method],params:match,method:cb})}}}),tests.length>0){let promises=[];tests.forEach(test=>{promises.push(test.test(request,kit,test.params))}),Promise.all(promises).then(results=>{let ok=!1;for(let x=0;x<results.length;x++)if(results[x]){ok=tests[x];break}if(ok&&ok.method)resolve(ok.method(request,kit,ok.params));else{if(ok&&!ok.method)return reject({code:400,message:"Missing Methods."});if(!ok)return reject({code:400,message:"Permission Denied"})}}).catch(err=>{if(err&&err.message)return reject(err);reject({code:400,message:"Permission Denied - "+err.toString()})})}else reject({code:400,message:"Missing Permissions"})})}return"undefined"!=typeof module&&module&&module.exports&&(module.exports=Memstore),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Channels),"undefined"!=typeof module&&module&&module.exports&&(module.exports=theRules),starbase.Database=function(dbName){let database={put:(dbName,key,data)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});if(!key)return reject({code:400,message:"A key is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite");tx.objectStore(dbName).put(data,key),tx.oncomplete=(()=>{resolve({db:dbName,event:"write",key:key,timestamp:Date.now()}),db.close()}),tx.onerror=(err=>{db.close(),reject(err)})})}),get:(dbName,key)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});if(!key)return reject({code:400,message:"A key is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readonly"),request=tx.objectStore(dbName).get(key);tx.oncomplete=(()=>{resolve({key:key,value:request.result}),db.close()}),tx.onerror=(err=>{db.close(),reject(err)})})}),del:(dbName,keys)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});if(!keys)return reject({code:400,message:"A key or an array of keys is required."});let db,keyPaths=[];keyPaths="string"==typeof keys?[keys]:keys;let open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite"),store=tx.objectStore(dbName);for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);tx.oncomplete=(()=>{resolve({db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()}),db.close()}),tx.onerror=(err=>{db.close(),reject(err)})})}),list:(dbName,query)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite"),store=tx.objectStore(dbName);query&&"object"==typeof query||(query={});let limit,results=[],gt=query.gt||"\0",lt=query.lt||"￿";query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let request=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);request.onsuccess=(()=>{let cursor=request.result;if(!limit&&cursor||results.length<limit&&cursor){let result={};query.values?(result.key=cursor.primaryKey,result.value=cursor.value):result=cursor.primaryKey,results.push(result),cursor.continue()}}),tx.oncomplete=(()=>{db.close(),resolve(results)}),tx.onerror=(err=>{db.close(),reject(err)})})}),deleteDB:dbName=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});let request=indexedDB.deleteDatabase(dbName);request.onsuccess=(()=>{let e={db:dbName,event:"deleteDB",timestamp:Date.now()};resolve(e)}),request.onerror=request.onblocked=(err=>{reject({code:400,message:"Error deleting database. "+err.toString()})})}),exportDB:dbName=>database.list(dbName,{values:!0}),importDB:(dbName,items)=>new Promise((resolve,reject)=>{if(!dbName)return reject({code:400,message:"dbName (Database Name) is required."});let db,open=indexedDB.open(dbName,1);open.onupgradeneeded=(()=>{(db=open.result).createObjectStore(dbName)}),open.onsuccess=(()=>{let tx=(db=open.result).transaction(dbName,"readwrite"),store=tx.objectStore(dbName);for(let x=0;x<items.length;x++)store.put(items[x].value,items[x].key);tx.oncomplete=(()=>{let e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};db.close(),resolve(e)}),tx.onerror=(err=>{db.close(),reject({code:400,message:"Error importing database. "+err.toString()})})})}),db:dbName=>{dbName||(dbName="test");let onEvent,db={onEvent:cb=>{onEvent=cb}},eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)};return db.put=((key,data)=>new Promise((resolve,reject)=>{database.put(dbName,key,data).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db.get=((key,data)=>database.get(dbName,key)),db.del=(keys=>new Promise((resolve,reject)=>{database.del(dbName,keys).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db.list=(query=>database.list(dbName,query)),db.deleteDB=(()=>new Promise((resolve,reject)=>{database.deleteDB(dbName).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db.exportDB=(()=>database.exportDB(dbName)),db.importDB=(data=>new Promise((resolve,reject)=>{database.importDB(dbName,data).then(result=>{eventHandler(result),resolve(result)}).catch(reject)})),db}};return database.db(dbName)},starbase.Memstore=Memstore,starbase.Channels=Channels,starbase.Client=function(serverPath){let token=null,tokenHandler=null;const request=req=>new Promise(async(resolve,reject)=>{tokenHandler&&"function"==typeof tokenHandler&&(token=await tokenHandler());let body={};body.path=req.path||null,body.method=req.method||null,body.data=req.data||null,body.token=req.token||token||null,fetch(serverPath,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(body)}).then(async response=>{let result=await response.json();return response.status>399?reject(result):resolve(result)})}),setToken=newToken=>(token=newToken,!0),Channel=requestPath=>{let parsedPath=(requestPath=>{let reqPath,parts=(reqPath=requestPath?requestPath.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),channel="/"+parts.slice(0,-1).join("/"),key=parts.slice(-1)[0],slash="";return"/"!==channel&&(slash="/"),{path:channel+slash+key,channel:channel,key:key,slash:slash}})(requestPath).path;return{channel:()=>parsedPath,setToken:token=>{setToken(token)},setTokenHandler:cb=>{(cb=>(tokenHandler=cb,!0))(cb)},request:req=>request({method:req.method||null,path:req.path||parsedPath,data:req.data||null,token:req.token||null}),put:data=>((path,data)=>request({method:"put",path:path,data:data}))(parsedPath,data),get:query=>((path,query)=>request({method:"get",path:path,data:query}))(parsedPath,query),del:()=>(path=>request({method:"del",path:path}))(parsedPath),list:query=>((path,data)=>request({method:"list",path:path,data:data}))(parsedPath,query),path:path=>{path||(path="/");let slash="";return"/"!==parsedPath&&(slash="/"),Channel(parsedPath+slash+path)}}};return Channel("/")},starbase.WebSQL=function(dbName=null,size=2097152){let run=async(statement=null,values=[])=>new Promise((resolve,reject)=>{openDatabase(dbName,1,dbName,size||2097152).transaction(tx=>{tx.executeSql(statement||null,values||[],(t,r)=>{r.tx=t,resolve(r)},(t,e)=>{reject({message:"Error executing SQL statement.",error:e,tx:t})})})});return{run:run,datastore:tableName=>{let store={},created=!1,onEvent=null;const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},createStore=async()=>{let create=await run("create table if not exists "+tableName+" (key text primary key not null unique, value text)");return created=!0,create};return store.onEvent=(cb=>{onEvent=cb}),store.put=(async(key,value)=>(created||await createStore(),new Promise(async(resolve,reject)=>{if(!key||"string"!=typeof key)return reject({code:400,message:"A key is required."});let val=JSON.stringify(value);if(await run("replace into "+tableName+" (key, value) values (?,?)",[key,val]).catch(err=>null)){let e={event:"write",key:key,timestamp:Date.now()};eventHandler(e),resolve(e)}else reject({code:400,message:"Could not write data to key."})}))),store.get=(async key=>(created||await createStore(),new Promise(async(resolve,reject)=>{let read=await run("select * from "+tableName+" where key = ?",[key]).catch(err=>null),result={key:key,value:null},rows=Array.from(read.rows);rows&&rows.length>0&&(result.value=JSON.parse(rows[0].value||null)),resolve(result)}))),store.del=(async keys=>{if(created||await createStore(),!keys)return Promise.reject({code:400,message:"A key or an array of keys is required."});let keyIds=[];keyIds="string"==typeof keys?[keys]:keys;let ks=Array.from(new Uint8Array(keyIds.length)).map(val=>"?").join(","),e=(await run("delete from "+tableName+" where key in ("+ks+")",keyIds).catch(err=>(console.log(err),null)),{event:"delete",keys:keyIds,timestamp:Date.now()});return eventHandler(e),e}),store.list=(async(query={})=>{created||await createStore();let statement="select key ";query.values&&(statement+=", value "),statement+="from "+tableName+" ";let values=[];(query.lt||query.gt)&&(statement+="where ",query.lt&&(statement+="key < ? ",values.push(query.lt.toString())),query.gt&&(values[0]&&(statement+="and "),statement+="key > ? ",values.push(query.gt.toString()))),statement+="order by key ",query&&query.reverse&&(statement+="desc "),query&&query.limit&&!isNaN(query.limit)&&(statement+="limit "+parseInt(query.limit)+" ");let result=await run(statement,values).catch(err=>(console.log(err),null));return Array.from(result.rows).map(row=>{let key=row.key.toString(),item=key;return query.values&&(item={key:key,value:JSON.parse(row.value)}),item})}),store.importDB=(async dbArray=>{if(created||await createStore(),!dbArray||dbArray.length<1){let e={db:tableName,event:"importDB",keys:[],timestamp:Date.now()};return eventHandler(e),e}let statement="replace into "+tableName+"(key, value) values ",values=[],keys=[];for(let i=0;i<dbArray.length;i++)statement+="(?,?), ",values.push(dbArray[i].key.toString()),values.push(JSON.stringify(dbArray[i].value)),keys.push(dbArray[i].key);statement=statement.slice(0,-2),await sql.run(statement,values);let e={db:tableName,event:"importDB",keys:keys,timestamp:Date.now()};return eventHandler(e),e}),store.exportDB=(async()=>(created||await createStore(),store.list({deep:!0,values:!0}))),store.deleteDB=(async()=>(created||await createStore(),sql.run("drop table if exists "+tableName).then(result=>{let e={db:tableName,event:"deleteDB",timestamp:Date.now()};return created=!1,eventHandler(e),e}))),store}}},starbase.Socket=function(server){let stateHandler,messageHandler,errorHandler,ws=null,closed=!1;const ERROR=e=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(e),console.error(e)},stateChange=state=>{stateHandler&&"function"==typeof stateHandler&&stateHandler(state)},onopen=e=>{stateChange("connected"),closed=!1},onclose=e=>{stateChange("disconnected"),closed||ERROR("disconnected.")},onmessage=msg=>{if(messageHandler&&"function"==typeof messageHandler)try{msg=JSON.parse(msg.data),messageHandler(msg)}catch(e){}},onerror=err=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(err)};let socket={getState:()=>!(!ws||1!==ws.readyState)};return socket.connect=socket.open=(()=>{ws&&1===ws.readyState?ERROR("Already connected."):server?((ws=new WebSocket(server)).onopen=onopen,ws.onmessage=onmessage,ws.onclose=onclose,ws.onerror=onerror):ERROR("No server provided.")}),socket.send=(message=>{ws&&1===ws.readyState?ws.send(JSON.stringify(message),err=>{err?ERROR(err.toString()):console.log("Message Sent")}):ERROR("Not Connected")}),socket.close=(()=>{closed=!0,ws&&1===ws.readyState?ws.close():ERROR("Not Connected")}),socket.onMessage=(handler=>{messageHandler=handler}),socket.onState=(cb=>{stateHandler=cb}),socket.onError=(cb=>{errorHandler=cb}),socket.setServer=(socketURL=>{server=socketURL}),socket},starbase.Services=function(settings={}){const{servicesURL:servicesURL,dbName:dbName,appName:appName,starbase:starbase}=settings;let servicesType=servicesURL;appName&&"string"==typeof appName&&(servicesType=servicesURL+"/apps/"+appName);const Database=starbase.Database,Channels=starbase.Channels,Client=starbase.Client,db=(starbase.Auth,starbase.Profiles,starbase.Admin,Channels(Database(dbName))),auth=starbase.Auth(Client(servicesType+"/auth"),db);return{db:db,auth:auth,profiles:starbase.Profiles(starbase.Client(servicesType+"/profiles"),auth),admin:starbase.Admin(starbase.Client(servicesType+"/admin"),auth),starbase:starbase}},starbase.theRules=theRules,starbase.Auth=function(api=null,localDB=null,options={}){if(options&&"object"==typeof options||(options={}),!api)throw"Starbase Channels API Client is missing.";if(!localDB)throw"Starbase Channels Database is missing.";let db=localDB,request=(method,credentials)=>api.path("/").request({method:method,data:credentials}),tokenPath=(options.parentChannel||"/auth/token").toString(),stateHandler=null,authToken=null,user=null,stateChange=async token=>{token||(token=null),authToken=token,db&&await db.path(tokenPath).put({token:authToken}),authToken&&authToken.user?(user=authToken.user,auth.user=user):(user=null,auth.user=user),stateHandler&&"function"==typeof stateHandler&&stateHandler(authToken)},auth={user:null,getToken:()=>(async()=>new Promise(async(resolve,reject)=>{if(!authToken&&db){let storedToken=await db.path(tokenPath).get().then(result=>result.data).catch(err=>null);storedToken&&storedToken.token&&(authToken=storedToken.token,stateChange(authToken))}return authToken?authToken.accessExpires<Date.now()?authToken.refreshExpires>Date.now()?void request("refreshToken",authToken).then(result=>(stateChange(result),resolve(result.accessToken))).catch(err=>(stateChange(null),reject(err))):(stateChange(null),reject({code:400,message:"Invalid or expired token."})):resolve(authToken.accessToken):resolve(null)}))(),onStateChange:cb=>{stateHandler=cb},createUser:(username,password)=>new Promise((resolve,reject)=>{request("createUser",{username:username,password:password}).then(resolve).catch(reject)}),deleteUser:(username,password)=>new Promise((resolve,reject)=>{request("deleteUser",{username:username,password:password}).then(resolve).catch(reject)}),changePassword:(username,password,newPassword)=>new Promise((resolve,reject)=>{request("changePassword",{username:username,password:password,newPassword:newPassword}).then(resolve).catch(reject)}),signIn:(username,password)=>new Promise((resolve,reject)=>{request("signIn",{username:username,password:password}).then(token=>{stateChange(token),resolve(token)}).catch(err=>{reject(err)})}),signOut:()=>new Promise((resolve,reject)=>{stateChange(null),resolve({message:"Signed out."})})};return db&&auth.getToken().catch(err=>{}),auth},starbase.Admin=function(api,auth){if(!api)throw"Starbase Channels API Client object is missing.";if(!auth)throw"Starbase Authentication object is missing.";return api.setTokenHandler(auth.getToken),api},starbase.Profiles=function(api=null,auth=null){if(!api)throw"The Starbase Channels API client is missing";if(!auth)throw"The Starbase Authentication client is missing";return{getProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).get()},deleteProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).del()},updateProfile:async function(username,profile){return api.setToken(await auth.getToken()),api.path(username).put(profile)},listProfiles:async function(query={}){return query&&"object"==typeof query||((query={}).limit=10),(!query.limit||query.limit>10)&&(query.limit=10),api.setToken(await auth.getToken()),api.list(query)},auth:auth}},starbase}