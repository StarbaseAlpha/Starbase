"use strict";function Starbase(){let starbase={};function Memstore(){let onEvent,store={},data={};const clone=src=>{let target={};if("string"==typeof src)return src.toString();src instanceof Array&&(target=[]);for(let prop in src)src[prop]&&"object"==typeof src[prop]?target[prop]=clone(src[prop]):target[prop]=src[prop];return target};let eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)};return store.onEvent=(cb=>{onEvent=cb}),store.put=(async(key,value)=>{data[key]=clone(value);let e={event:"write",key:key,timestamp:Date.now()};return eventHandler(e),e}),store.get=(async key=>clone({key:key,value:data[key]})),store.del=(async keys=>{let keyPaths=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(key=>{delete data[key]});let e={event:"delete",keys:keyPaths,timestamp:Date.now()};return eventHandler(e),e}),store.list=(async query=>{query=query||{};let items=[];for(let key in data)query.values?items.push({key:key,value:data[key]}):items.push(key);query.values?items.sort((a,b)=>a.key<b.key?-1:a.key>b.key?1:0):items.sort(),query.reverse&&items.reverse();let results=[];for(let i=0;i<items.length&&!(query.limit&&results.length>=query.limit);i++)query.gt||query.lt?(query.values&&(query.gt&&items[i].key<=query.gt||query.lt&&items[i].key>=query.lt||results.push(items[i])),query.values||query.gt&&items[i]<=query.gt||query.lt&&items[i]>=query.lt||results.push(items[i])):results.push(items[i]);return clone(results)}),store.importDB=(async items=>{items.forEach(item=>{data[item.key]=clone(item.value)});let e={event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};return eventHandler(e),e}),store.exportDB=(async()=>store.list({values:!0})),store.deleteDB=(async()=>{data={};let e={event:"deleteDB",timestamp:Date.now()};return eventHandler(e),e}),store}function Channels(db){let onEvent;const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},Projection=(doc,projection)=>{let result={};for(let k in doc)projection[k]&&("object"==typeof projection[k]?result[k]=Projection(doc[k],projection[k]):result[k]=doc[k]);return result},Filter=(doc,filter)=>{let filtered=!1;if("string"==typeof filter&&"string"==typeof doc){let found=((query,data)=>{let y=new RegExp(filter.split(" ").map(val=>"(?=.*"+val+")").join(""),"i");return data.match(y)})(0,doc);return!doc||!found}for(let k in filter){if(!doc[k]){filtered=!0;break}if(typeof filter[k]!=typeof doc[k]){filtered=!0;break}if(typeof filter[k]==typeof doc[k]&&(filtered=Filter(doc[k],filter[k])))break}return filtered},ParsePath=requestPath=>{let reqPath,parts=(reqPath=requestPath?requestPath.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),channel="/"+parts.slice(0,-1).join("/"),key=parts.slice(-1)[0],slash="";return"/"!==channel&&(slash="/"),{path:channel+slash+key,channel:channel,key:key,slash:slash,dsPath:"!"+channel+"!"+key}},Channel=(db,requestPath)=>{let parsedPath=ParsePath(requestPath).path;return{channel:()=>parsedPath,put:data=>Put(db,parsedPath,data),get:query=>Get(db,parsedPath,query),del:()=>Del(db,parsedPath),list:query=>List(db,parsedPath,query),parse:(path=null)=>ParsePath((path||parsedPath).toString()),path:path=>{path||(path="/");let slash="";return"/"!==parsedPath&&(slash="/"),Channel(db,parsedPath+slash+path)}}},Put=(db,requestPath,data)=>new Promise((resolve,reject)=>{if(!data)return reject({code:400,message:"Data is required."});if(requestPath.match(/\!/))return reject({code:400,message:"Invalid Path. The exclamation point (!) is a reserved character."});let{path:path,channel:channel,key:key,slash:slash}=ParsePath(requestPath);db.put("!"+channel+"!"+key,data).then(result=>{let response={event:result.event,path:channel+slash+(key||""),channel:channel,key:key||"",timestamp:result.timestamp};if("/"===channel&&(!key||""===key))return eventHandler(response),resolve(response);Get(db,channel).then(found=>{eventHandler(response),resolve(response)}).catch(err=>{Put(db,channel,{}).then(written=>{eventHandler(response),resolve(response)}).catch(reject)})}).catch(reject)}),Get=(db,requestPath,query)=>new Promise((resolve,reject)=>{let{path:path,channel:channel,key:key,slash:slash}=ParsePath(requestPath);db.get("!"+channel+"!"+key).then(response=>{if(!response.value)return reject({code:404,message:"Not Found"});let result={path:channel+slash+key,channel:channel,key:key,data:response.value};query&&query.projection&&"object"==typeof query.projection&&(result=Projection(result,query.projection)),query&&query.children?List(db,result.path,query.children).then(children=>{children&&children.data?result.children=children.data:result.children=[],resolve(result)}):resolve(result)}).catch(reject)}),Del=(db,requestPath)=>new Promise((resolve,reject)=>{let{path:path,channel:channel,key:key,slash:slash}=ParsePath(requestPath);db.list({gt:"!"+channel+slash+key+"!",lt:"!"+channel+slash+key+"￿/"}).then(results=>{results.unshift("!"+channel+"!"+key),db.del(results).then(deleted=>{let paths=deleted.keys.map(val=>val.replace(/^\!/,"").replace(/\!/g,"/").replace(/\/\//g,"/").replace(/\/\//g,"/")),e={event:deleted.event,paths:paths,timestamp:deleted.timestamp};eventHandler(e),resolve(e)})})}),List=(db,requestPath="/",query={})=>new Promise((resolve,reject)=>{query&&"object"==typeof query||(query={});let channel=requestPath.toString(),slash="";"/"!==channel&&(slash="/",channel="/"+channel.replace(/^\//,"").replace(/\/$/,""));let gt="!"+channel+"!"+(query.gt||""),lt="!"+channel+"!"+(query.lt||"￿");!!query.deep&&(lt="!"+channel+slash+"￿"),db.list({gt:gt,lt:lt,reverse:query.reverse||!1,values:query.values||!1,limit:query.limit||null}).then(results=>{let last=null,data=results.map(val=>{"object"!=typeof val&&(val={key:val});let channel=val.key.replace(/^\!/,"").split("!")[0],key=val.key.replace(/^\!/,"").split("!")[1]||"/",slash="";"/"!==channel&&(slash="/");let result={path:channel+slash+key,channel:channel,key:key};return last=result.key,val.value&&(result.data=val.value),query.projection&&"object"==typeof query.projection&&(result=Projection(result,query.projection)),result}).filter(val=>!(query.values&&val.data&&query.filter&&"object"==typeof query.filter&&Filter(val.data,query.filter))),cursor=null;last&&(cursor={},query.limit&&(cursor.limit=parseInt(query.limit)),query.reverse?(cursor.reverse=!0,cursor.lt=last):(cursor.reverse=!1,cursor.gt=last),query.values&&(cursor.values=!0),query.filter&&(cursor.filter=query.filter),query.projection&&(cursor.projection=query.projection)),resolve({data:data,cursor:cursor})})});let channel=Channel(db,"/");return channel.onEvent=(cb=>{onEvent=cb}),channel.datastore=db,channel}function theRules(rules=[],request={},kit={}){return new Promise((resolve,reject)=>{let method=request.method||null,path=(request.path||"/").toString(),tests=[];if(rules&&"object"==typeof rules&&!rules.forEach&&(rules=[rules]),rules.forEach(rule=>{if(rule.path){let match=((rulePath,testPath)=>{let rule=(rulePath||"").toString().replace(/^\/|\/$/g,"").split("/"),test=(testPath||"").toString().replace(/^\/|\/$/g,"").split("/");if(rule.length!==test.length)return null;let params={};for(let x=0;x<rule.length;x++)if(rule[x]!==test[x]){if(":"!==rule[x].substring(0,1)){params=null;break}params[rule[x].substring(1,rule[x].length)]=test[x]}return params})(rule.path,path);if(match&&rule.rules&&rule.rules[method]){let cb;rule.methods&&rule.methods[method]&&"function"==typeof rule.methods[method]&&(cb=rule.methods[method]),tests.push({test:rule.rules[method],params:match,method:cb})}}}),tests.length>0){let promises=[];tests.forEach(test=>{promises.push(test.test(request,kit,test.params))}),Promise.all(promises).then(results=>{let ok=!1;for(let x=0;x<results.length;x++)if(results[x]){ok=tests[x];break}if(ok&&ok.method)resolve(ok.method(request,kit,ok.params));else{if(ok&&!ok.method)return reject({code:400,message:"Missing Methods."});if(!ok)return reject({code:400,message:"Permission Denied"})}}).catch(err=>{if(err&&err.message)return reject(err);reject({code:400,message:"Permission Denied - "+err.toString()})})}else reject({code:400,message:"Missing Permissions"})})}function Cryptic(webCrypto,encoder,decoder){let cryptic={},crypto=webCrypto;"undefined"!=typeof window&&(crypto=window.crypto||webCrypto);let TextEncoder=encoder,TextDecoder=decoder;"undefined"!=typeof window&&(TextEncoder=window.TextEncoder,TextDecoder=window.TextDecoder);const toHex=cryptic.toHex=(byteArray=>Array.from(new Uint8Array(byteArray)).map(val=>("0"+val.toString(16)).slice(-2)).join("")),encode=(cryptic.fromHex=(str=>{let result=new Uint8Array(str.match(/.{0,2}/g).map(val=>parseInt(val,16)));return result.slice(0,result.length-1)}),cryptic.encode=(byteArray=>btoa(Array.from(new Uint8Array(byteArray)).map(val=>String.fromCharCode(val)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,""))),decode=cryptic.decode=(str=>new Uint8Array(atob(str.replace(/\_/g,"/").replace(/\-/g,"+")).split("").map(val=>val.charCodeAt(0)))),fromText=cryptic.fromText=(string=>(new TextEncoder).encode(string)),toText=cryptic.toText=(byteArray=>(new TextDecoder).decode(byteArray)),random=(cryptic.combine=((bitsA=[],bitsB=[])=>{let A=bitsA,B=bitsB;"string"==typeof bitsA&&(A=decode(bitsA)),"string"==typeof bitsB&&(B=decode(bitsB));let a=new Uint8Array(A),b=new Uint8Array(B),c=new Uint8Array(a.length+b.length);return c.set(a),c.set(b,a.length),c}),cryptic.random=(size=>crypto.getRandomValues(new Uint8Array(size)))),pbkdf2=(cryptic.createECDH=(async(curve="P-256")=>{let DH=await crypto.subtle.generateKey({name:"ECDH",namedCurve:curve},!0,["deriveBits"]),pub=await crypto.subtle.exportKey("spki",DH.publicKey),key=encode(await crypto.subtle.exportKey("pkcs8",DH.privateKey));return{pub:encode(pub),key:key}}),cryptic.createECDSA=(async(curve="P-256")=>{let user=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:curve},!0,["sign","verify"]),pub=await crypto.subtle.exportKey("spki",user.publicKey),key=encode(await crypto.subtle.exportKey("pkcs8",user.privateKey));return{pub:encode(pub),key:key}}),cryptic.ecdsaSign=cryptic.sign=(async(key,msg,curve="P-256",hashAlg="SHA-256")=>{let message=msg.toString(),signKey=await crypto.subtle.importKey("pkcs8",decode(key),{name:"ECDSA",namedCurve:curve},!1,["sign"]),sig=await crypto.subtle.sign({name:"ECDSA",hash:hashAlg},signKey,fromText(message));return encode(sig)}),cryptic.ecdsaVerify=cryptic.verify=(async(pub,sig,msg,curve="P-256",hashAlg="SHA-256")=>{let message=msg.toString(),verifyKey=await crypto.subtle.importKey("spki",decode(pub),{name:"ECDSA",namedCurve:curve},!1,["verify"]);return await crypto.subtle.verify({name:"ECDSA",hash:hashAlg},verifyKey,decode(sig),fromText(message))}),cryptic.hmacSign=(async(bits,msg,hashAlg="SHA-256")=>{let message=msg.toString(),hmacKey=await crypto.subtle.importKey("raw",bits,{name:"HMAC",hash:hashAlg},!1,["sign"]),sig=await crypto.subtle.sign({name:"HMAC",hash:hashAlg},hmacKey,fromText(message));return encode(sig)}),cryptic.hmacVerify=(async(bits,sig,msg,hashAlg="SHA-256")=>{let message=msg.toString(),verifyKey=await crypto.subtle.importKey("raw",bits,{name:"HMAC",hash:hashAlg},!1,["verify"]);return await crypto.subtle.verify({name:"HMAC",hash:hashAlg},verifyKey,decode(sig),fromText(message))}),cryptic.digest=(async(bits,hashAlg="SHA-256")=>{let digest=await crypto.subtle.digest({name:hashAlg},bits);return toHex(digest)}),cryptic.pbkdf2=(async(bits,salt,iterations=1,size=256,hashAlg="SHA-256")=>{let key=await crypto.subtle.importKey("raw",bits,{name:"PBKDF2"},!1,["deriveBits"]),result=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:iterations,hash:hashAlg},key,size);return encode(result)})),encrypt=(cryptic.kdf=(async(bits,salt,info,size,hashAlh="SHA-256")=>{let key=await cryptic.hmacSign(bits,cryptic.toText(info));return await cryptic.pbkdf2(cryptic.decode(key),salt,1,size)}),cryptic.ecdh=(async(key,pub,curve="P-256",size=256)=>{let pubKey=await crypto.subtle.importKey("spki",decode(pub),{name:"ECDH",namedCurve:curve},!0,[]),privateKey=await crypto.subtle.importKey("pkcs8",decode(key),{name:"ECDH",namedCurve:curve},!0,["deriveBits"]),shared=await crypto.subtle.deriveBits({name:"ECDH",public:pubKey},privateKey,size);return encode(shared)}),cryptic.encrypt=(async(plaintext,bits,AD=null)=>{let key=await crypto.subtle.importKey("raw",bits,{name:"AES-GCM"},!1,["encrypt"]),iv=random(12),msg=fromText(plaintext),cipher=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv,additionalData:AD||fromText("")},key,msg);return encode(iv)+"."+encode(cipher)})),decrypt=cryptic.decrypt=(async(ciphertext="",bits,AD=null)=>{let key=await crypto.subtle.importKey("raw",bits,{name:"AES-GCM"},!1,["decrypt"]),iv=decode(ciphertext.split(".")[0]),cipher=decode(ciphertext.split(".")[1]),decrypted=await crypto.subtle.decrypt({name:"AES-GCM",iv:iv,additionalData:AD||fromText("")},key,cipher).catch(err=>{throw{message:"Failed to decrypt message.",error:err}});return toText(decrypted)});return cryptic.passwordEncrypt=(async(message,password="",iterations=1e5)=>{let salt=random(32),keyBits=await pbkdf2(fromText(password),salt,iterations,256),encrypted=await encrypt(message,decode(keyBits));return encode(fromText(iterations.toString()))+"."+encode(salt)+"."+encrypted}),cryptic.passwordDecrypt=(async(ciphertext="",password="")=>{let iterations=toText(decode(ciphertext.split(".")[0])),salt=ciphertext.split(".")[1],keyBits=await pbkdf2(fromText(password),decode(salt),iterations,256),encrypted=ciphertext.split(".").slice(2).join(".");return await decrypt(encrypted,decode(keyBits))}),cryptic}function CryptoDB(cryptic,datastore,memstore,secretKey,passwordKey){let SECRET=null,PASSWORD=null;const files=datastore,index=memstore;let indexName=null,loading=!1,loaded=!1,saving=!1,unsaved=!1;const hashPath=async path=>{let exists=await index.get(path);return exists&&exists.value?exists.value:await cryptic.hmacSign(SECRET,path)},Load=async()=>{if(loaded)return!0;if(loading)return resume();SECRET=cryptic.decode(await cryptic.kdf(cryptic.fromText(secretKey),cryptic.fromText(passwordKey),cryptic.fromText("SECRET"),256)),PASSWORD=cryptic.decode(await cryptic.kdf(cryptic.fromText(passwordKey),cryptic.fromText(secretKey),cryptic.fromText("PASSWORD"),256)),loading=!0,indexName=await cryptic.kdf(SECRET,PASSWORD,cryptic.fromText("INDEX"),256);let indexExists=(await files.get(indexName)).value;if(indexExists){let decrypted=await Decrypt(indexName,indexExists);await index.importDB(decrypted)}return loading=!1,loaded=!0},resume=()=>new Promise((resolve,reject)=>{setTimeout(()=>{resolve(Load())},100)}),save=async(force=!1)=>saving&&!force?(unsaved=!0,!0):(unsaved=!1,saving=!0,Encrypt(indexName,await index.exportDB()).then(encryptedFS=>{files.put(indexName,encryptedFS).then(async ok=>(saving=!1,!unsaved||save(!0)))})),Encrypt=async(path,data)=>{let random=cryptic.random(32),salt=cryptic.combine(random,cryptic.fromText(path)),bits=await cryptic.kdf(cryptic.combine(PASSWORD),salt,cryptic.fromText("ENCRYPT"),512),key=await cryptic.decode(bits).slice(0,32),ad=await cryptic.decode(bits).slice(32,64),encrypted=await cryptic.encrypt(JSON.stringify(data),key,ad);return cryptic.encode(random)+"."+encrypted},Decrypt=async(path,payload)=>{let random=payload.split(".")[0],encrypted=payload.split(".").slice(1).join("."),salt=cryptic.combine(random,cryptic.fromText(path)),bits=await cryptic.kdf(cryptic.combine(PASSWORD),salt,cryptic.fromText("ENCRYPT"),512),key=await cryptic.decode(bits).slice(0,32),ad=await cryptic.decode(bits).slice(32,64),decrypted=await cryptic.decrypt(encrypted,key,ad);return JSON.parse(decrypted)},Put=async(path,data)=>{loaded||await Load();let hash=await hashPath(path),encrypted=await Encrypt(path,data);return await files.put(hash,encrypted),await index.put(path,hash),await save(),{event:"write",timestamp:Date.now(),key:path}},List=async(query={})=>{loaded||await Load();let body=Object.assign({},query);body.values=!0;let list=await index.list(body);if(query.values){let promises=[];for(let i=0;i<list.length;i++)promises.push(Get(list[i].key));return await Promise.all(promises)}return list.map(file=>file.key)},Get=async path=>{loaded||await Load();let hash=await hashPath(path),encrypted=(await files.get(hash)).value,decrypted=null;return encrypted&&(decrypted=await Decrypt(path,encrypted)),{key:path,value:decrypted}};return Load(),{put:Put,get:Get,del:async paths=>{loaded||await Load();let keyPaths=paths;"string"==typeof paths&&(keyPaths=[paths]);let promises=[];for(let i=0;i<keyPaths.length;i++)promises.push((async()=>{let hash=await hashPath(keyPaths[i]);await files.del(hash),await index.del(keyPaths[i])})());return await Promise.all(promises),await save(),{event:"delete",timestamp:Date.now(),keys:keyPaths}},list:List,importDB:async data=>{loaded||await Load();let paths=[];for(let i=0;i<data.length;i++)paths.push(data[i].key),await Put(data[i].key,data[i].value);return await save(),{event:"importDB",timestamp:Date.now(),keys:paths}},exportDB:async()=>(loaded||await Load(),List({values:!0})),deleteDB:async()=>{let deleted=await files.deleteDB();return await index.deleteDB(),loaded=!1,indexName=null,Date.now(),deleted},onEvent:datastore.onEvent,exportIndex:async()=>(loaded||await Load(),index.list()),importIndex:async indexData=>{loaded||await Load();let promises=[];for(let i=0;i<indexData.length;i++)promises.push(hashPath(indexData[i]).then(result=>({key:indexData[i],value:result})));let results=await Promise.all(promises);return await index.importDB(results),await save(),!0},hashPath:hashPath,raw:datastore}}function Encryption(cryptic){if(!cryptic)throw"An instance of Starbase Cryptic is require.";async function createCard(user){return cloneState({idk:user.idk.pub,spk:user.spk.pub})}async function sessionHash(combinedDH,init){let hashed=await cryptic.kdf(combinedDH,new Uint8Array(32),cryptic.fromText("SIGNAL"),768),sharedKey=cryptic.decode(hashed).slice(0,32),authKey=cryptic.decode(hashed).slice(32,64),sessionId=cryptic.decode(hashed).slice(64,96),ad=cryptic.combine(cryptic.decode(init.from),cryptic.decode(init.to)),AD=await cryptic.kdf(cryptic.combine(authKey,ad),new Uint8Array(32),cryptic.fromText("AD"),256);return{sessionId:cryptic.encode(sessionId),sk:cryptic.encode(sharedKey),AD:AD,init:init}}async function rootKDF(rk,dh){let ratchet=await cryptic.kdf(cryptic.decode(dh),cryptic.decode(rk),cryptic.fromText("ROOT"),512);return[cryptic.encode(cryptic.decode(ratchet).slice(0,32)),cryptic.encode(cryptic.decode(ratchet).slice(32))]}async function chainKDF(ck){let mk=await cryptic.hmacSign(cryptic.decode(ck),"");return[await cryptic.hmacSign(cryptic.decode(ck),""),mk]}async function skipMessageKeys(state,until,maxSkip){if(state.Nr+maxSkip<until)return Promise.reject({message:"Too many skipped messages!"});if(state.CKr)for(;state.Nr<until;){let mk=null;[state.CKr,mk]=await chainKDF(state.CKr),state.MKSKIPPED[state.DHr]||(state.MKSKIPPED[state.DHr]={}),state.MKSKIPPED[state.DHr][state.Nr]=mk,state.Nr+=1}}function cloneState(src){let target={};if("string"==typeof src)return src.toString();src instanceof Array&&(target=[]);for(let prop in src)src[prop]&&"object"==typeof src[prop]?target[prop]=cloneState(src[prop]):target[prop]=src[prop];return target}function Session(sessionData){let sessionState=cloneState(sessionData),session={to:()=>cloneState(sessionData).user,send:async message=>{let state=cloneState(sessionState.state),payload=await async function(state,msg,AD,init){let mk=null;[state.CKs,mk]=await chainKDF(state.CKs);let header={dh:state.DHs.pub,pn:state.PN,n:state.Ns};state.Ns+=1;let AEAD=await cryptic.kdf(cryptic.combine(cryptic.decode(AD),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("AEAD"),256),KEY=await cryptic.kdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),encrypted={header:header,ciphertext:await cryptic.encrypt(JSON.stringify(msg),cryptic.decode(KEY),cryptic.decode(AEAD))};return init&&(encrypted.init=cloneState(init)),encrypted}(state,message,sessionState.AD||null,sessionState.init||null);return payload.to=sessionData.user.toString(),sessionState.state=cloneState(state),payload}};return session.read=(async payload=>{let state=cloneState(sessionState.state),decrypted=await async function(state,msgPayload={},AD,maxSkip=10){let{header:header,ciphertext:ciphertext}=msgPayload,AEAD=await cryptic.kdf(cryptic.combine(cryptic.decode(AD),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("AEAD"),256),found=await async function(state,header,ciphertext,AEAD){if(state.MKSKIPPED[header.dh]&&state.MKSKIPPED[header.dh][header.n]){let mk=state.MKSKIPPED[header.dh][header.n],KEY=await cryptic.kdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),plaintext=await cryptic.decrypt(ciphertext,cryptic.decode(KEY),cryptic.decode(AEAD)).catch(err=>null);return plaintext?(delete state.MKSKIPPED[header.dh][header.n],{header:header,plaintext:plaintext}):null}}(state,header,ciphertext,AEAD||null);if(found)return found;header.dh!==state.DHr&&(await skipMessageKeys(state,header.pn,maxSkip),await async function(state,header){state.PN=state.Ns,state.Ns=0,state.Nr=0,state.DHr=header.dh;let dh1=await cryptic.ecdh(state.DHs.key,state.DHr);[state.RK,state.CKr]=await rootKDF(state.RK,dh1),state.DHs=await cryptic.createECDH();let dh2=await cryptic.ecdh(state.DHs.key,state.DHr);return[state.RK,state.CKs]=await rootKDF(state.RK,dh2),!0}(state,header)),await skipMessageKeys(state,header.n,maxSkip);let mk=null;[state.CKr,mk]=await chainKDF(state.CKr),state.Nr+=1;let KEY=await cryptic.kdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),plaintext=await cryptic.decrypt(ciphertext,cryptic.decode(KEY),cryptic.decode(AEAD)).catch(err=>{throw{error:"failed to decrypt"}});return delete state.init,{header:header,plaintext:JSON.parse(plaintext)}}(state,payload,sessionState.AD||null);sessionState.init&&delete sessionState.init;let msg={header:payload.header,plaintext:decrypted.plaintext,from:session.to()};return sessionState.state=cloneState(state),msg}),session.save=(()=>{let backup={state:cloneState(sessionState.state)};return sessionState.sessionId&&(backup.sessionId=cloneState(sessionState.sessionId)),sessionState.init&&(backup.init=cloneState(sessionState.init)),sessionState.user&&(backup.user=cloneState(sessionState.user)),sessionState.AD&&(backup.AD=cloneState(sessionState.AD)),backup}),session}function User(userData){let userState=cloneState(userData),user={},useUser=()=>userState;return user.getCard=(async(includeOPK=!1)=>{let card=cloneState(userState.card);if(includeOPK){let opk=await cryptic.createECDH();userState.opks[opk.pub]=opk.key,card.opk=opk.pub.toString()}return card}),user.updateSPK=(async()=>{let spk=await async function(user){return await cryptic.createECDH()}();return userState.spk=spk,userState.card=await createCard(userState),!0}),user.sealEnvelope=(async(to,msg)=>(async function(userIDK,to,message){let idk=userIDK.pub,env={},epk=await cryptic.createECDH(),dh1=await cryptic.ecdh(epk.key,to),envSalt=cryptic.combine(cryptic.decode(to),cryptic.decode(epk.pub)),envBits=await cryptic.kdf(cryptic.decode(dh1),envSalt,cryptic.fromText("ENVELOPE"),768),envAD=cryptic.combine(cryptic.decode(envBits).slice(0,32),cryptic.combine(cryptic.decode(epk.pub),cryptic.decode(to))),envKey=cryptic.decode(envBits).slice(32,64),envChain=cryptic.decode(envBits).slice(64,96),sealed=await cryptic.encrypt(idk,envKey,envAD),dh2=await cryptic.ecdh(userIDK.key,to),sealSalt=cryptic.combine(envChain,cryptic.fromText(sealed)),sealBits=await cryptic.kdf(cryptic.decode(dh2),cryptic.combine(sealSalt,cryptic.decode(idk)),cryptic.fromText("SEAL"),512),sealAD=cryptic.combine(cryptic.decode(sealBits).slice(0,32),cryptic.decode(to)),sealKey=cryptic.decode(sealBits).slice(32,64);return env.to=to,env.epk=epk.pub,env.seal=sealed,env.ciphertext=await cryptic.encrypt(JSON.stringify(message),sealKey,sealAD),env})(useUser().idk,to,msg)),user.openEnvelope=(async env=>(async function(userIDK,env){let idk=userIDK.pub,epk=env.epk,dh1=await cryptic.ecdh(userIDK.key,epk),envSalt=cryptic.combine(cryptic.decode(idk),cryptic.decode(epk)),envBits=await cryptic.kdf(cryptic.decode(dh1),envSalt,cryptic.fromText("ENVELOPE"),768),envAD=cryptic.combine(cryptic.decode(envBits).slice(0,32),cryptic.combine(cryptic.decode(epk),cryptic.decode(idk))),envKey=cryptic.decode(envBits).slice(32,64),envChain=cryptic.decode(envBits).slice(64,96),from=await cryptic.decrypt(env.seal,envKey,envAD),dh2=await cryptic.ecdh(userIDK.key,from),sealSalt=cryptic.combine(envChain,cryptic.fromText(env.seal)),sealBits=await cryptic.kdf(cryptic.decode(dh2),cryptic.combine(sealSalt,cryptic.decode(from)),cryptic.fromText("SEAL"),512),sealAD=cryptic.combine(cryptic.decode(sealBits).slice(0,32),cryptic.decode(idk)),sealKey=cryptic.decode(sealBits).slice(32,64),contents=await cryptic.decrypt(env.ciphertext,sealKey,sealAD);return{from:from,contents:JSON.parse(contents)}})(useUser().idk,env)),user.createSession=(async card=>{let session=await async function(user,card){let epk=await cryptic.createECDH(),init={};init.to=card.idk,init.from=user.idk.pub.toString(),init.spk=card.spk,init.epk=epk.pub,card.opk&&(init.opk=card.opk);let dh1=await cryptic.ecdh(user.idk.key,init.spk),dh2=await cryptic.ecdh(epk.key,init.to),dh3=await cryptic.ecdh(epk.key,init.spk),dh4=null;return init.opk&&(dh4=await cryptic.ecdh(epk.key,init.opk)),sessionHash(await cryptic.combine(cryptic.combine(dh1,dh2),cryptic.combine(dh3,dh4)),init)}(useUser(),card);return session.user=card.idk,session.state=await async function(session){let state={};state.DHs=await cryptic.createECDH(),state.DHr=session.init.spk;let dh=await cryptic.ecdh(state.DHs.key,state.DHr);return[state.RK,state.CKs]=await rootKDF(session.sk,dh),state.CKr=null,state.Ns=0,state.Nr=0,state.PN=0,state.MKSKIPPED={},state}(session),delete session.sk,Session(session)}),user.openSession=(async init=>{let session=await async function(user,init){let dh1=await cryptic.ecdh(user.spk.key,init.from),dh2=await cryptic.ecdh(user.idk.key,init.epk),dh3=await cryptic.ecdh(user.spk.key,init.epk),dh4=null;if(init.opk&&user.opks[init.opk]){let opk=user.opks[init.opk].toString();delete user.opks[init.opk],dh4=await cryptic.ecdh(opk,init.epk)}return sessionHash(await cryptic.combine(cryptic.combine(dh1,dh2),cryptic.combine(dh3,dh4)),init)}(useUser(),init);return session.user=init.from,session.recvFrom=useUser().idk.pub.toString(),session.state=await async function(session,spk){let state={};return state.DHs=spk,state.DHr=null,state.RK=session.sk,state.CKs=null,state.CKr=null,state.Ns=0,state.Nr=0,state.PN=0,state.MKSKIPPED={},state}(session,useUser().spk),delete session.sk,Session(session)}),user.loadSession=(async session=>Session(session)),user.save=(()=>cloneState(userState)),user}let cynops={createUser:async()=>User(await async function(){let idk=await cryptic.createECDH(),spk=await cryptic.createECDH();return cloneState({idk:idk,spk:spk,opks:{},card:await createCard({idk:idk,spk:spk})})}()),loadUser:async userData=>User(userData)};return cynops}return"undefined"!=typeof module&&module&&module.exports&&(module.exports=Memstore),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Channels),"undefined"!=typeof module&&module&&module.exports&&(module.exports=theRules),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Cryptic),"undefined"!=typeof module&&module&&module.exports&&(module.exports=CryptoDB),"undefined"!=typeof module&&module&&module.exports&&(module.exports=Encryption),starbase.Database=function(dbName){let db,onEvent;window.indexedDB||(window.indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB),window.IDBTransaction||(window.IDBTransaction=window.IDBTransaction||window.webkitIDBTransaction||window.msIDBTransaction||{READ_WRITE:"readwrite"}),window.IDBKeyRange||(window.IDBKeyRange=window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange),dbName||(dbName="test");const eventHandler=e=>{onEvent&&"function"==typeof onEvent&&onEvent(e)},close=async()=>(db&&(db.close(),db=null),!0),open=async()=>new Promise((resolve,reject)=>{if(db)return resolve(db);let open=indexedDB.open(dbName,1);open.onerror=(e=>{reject({code:400,message:err.message||err.toString()||"Error!"})}),open.onupgradeneeded=(e=>{(db=e.target.result).createObjectStore(dbName,{keyPath:"key"})}),open.onsuccess=(e=>{db=e.target.result,resolve(db)})}),list=query=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readonly").objectStore(dbName);query&&"object"==typeof query||(query={});let limit,results=[],gt=query.gt||"\0",lt=query.lt||"￿";query.limit&&(limit=parseInt(query.limit));let reverse="next";query.reverse&&(reverse="prev");let req=store.openCursor(IDBKeyRange.bound(gt,lt,!0,!0),reverse);req.onsuccess=(()=>{let cursor=req.result;if(!limit&&cursor||results.length<limit&&cursor){let result={};result=query.values?{key:cursor.value.key,value:cursor.value.value}:cursor.key,results.push(result),cursor.continue()}else resolve(results)}),req.onerror=req.onblocked=(err=>{reject({code:400,message:"Error deleting database. "+err.toString()})})});return{put:(key,value)=>new Promise(async(resolve,reject)=>{db||await open();let req=db.transaction([dbName],"readwrite").objectStore(dbName).put({value:value,key:key});req.onsuccess=(()=>{let e={db:dbName,event:"write",key:key,timestamp:Date.now()};eventHandler(e),resolve(e)}),req.onerror=req.onblocked=(err=>{reject({code:400,message:err.message||err.toString()||"Error!"})})}),get:key=>new Promise(async(resolve,reject)=>{db||await open();let req=db.transaction([dbName],"readonly").objectStore(dbName).get(key);req.onsuccess=(e=>{let result=req.result,value=null;result&&result.value&&(value=result.value),resolve({key:key,value:value})}),req.onerror=req.onblocked=(err=>{reject({code:400,message:err.message||err.toString()||"Error!"})})}),del:(keys=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName),keyPaths=[];if(!keys)return reject({code:400,message:"A key or an array of keys is required."});let ops=[];(keyPaths="string"==typeof keys?[keys]:keys).forEach(path=>{ops.push({type:"del",key:path})});for(let i=0;i<keyPaths.length;i++)store.delete(keyPaths[i]);store.transaction.oncomplete=(()=>{let e={db:dbName,event:"delete",keys:keyPaths,timestamp:Date.now()};eventHandler(e),resolve(e)}),store.transaction.onerror=(err=>{reject({code:400,message:err.message||err.toString()||"Error!"})})}),list:list,deleteDB:()=>new Promise(async(resolve,reject)=>{await close();let req=indexedDB.deleteDatabase(dbName);req.onsuccess=function(){let e={db:dbName,event:"deleteDB",timestamp:Date.now()};eventHandler(e),resolve(e)},req.onerror=req.onblocked=(e=>{reject({code:400,message:"Error deleting database. "+e.toString()})})}),exportDB:async()=>await list({values:!0}),importDB:(items=[])=>new Promise(async(resolve,reject)=>{db||await open();let store=db.transaction([dbName],"readwrite").objectStore(dbName);store.transaction.oncomplete=(()=>{let e={db:dbName,event:"importDB",keys:items.map(val=>val.key),timestamp:Date.now()};eventHandler(e),resolve(e)}),store.onerror=(err=>{reject({code:400,message:"Error importing database. "+err.toString()})});for(let x=0;x<items.length;x++)await store.put({key:items[x].key,value:items[x].value})}),onEvent:cb=>{onEvent=cb},close:close}},starbase.Memstore=Memstore,starbase.Channels=Channels,starbase.Client=function(serverPath){const ParsePath=requestPath=>{let reqPath,parts=(reqPath=requestPath?requestPath.toString():"/").toString().replace(/\/\//g,"/").replace(/^\//,"").replace(/\/$/,"").replace(/\/\//g,"/").split("/"),channel="/"+parts.slice(0,-1).join("/"),key=parts.slice(-1)[0],slash="";return"/"!==channel&&(slash="/"),{path:channel+slash+key,channel:channel,key:key,slash:slash,dsPath:"!"+channel+"!"+key}};let token=null,tokenHandler=null;const request=req=>new Promise(async(resolve,reject)=>{tokenHandler&&"function"==typeof tokenHandler&&(token=await tokenHandler());let body={};body.path=req.path||null,body.method=req.method||null,body.data=req.data||null,body.token=req.token||token||null,fetch(serverPath,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(body)}).then(async response=>{let result=await response.json();return response.status>399?reject(result):resolve(result)}).catch(err=>reject({code:500,message:err.message||err.toString()||"Error!"}))}),setToken=newToken=>(token=newToken,!0),Channel=requestPath=>{let parsedPath=ParsePath(requestPath).path;return{channel:()=>parsedPath,setToken:token=>{setToken(token)},setTokenHandler:cb=>{(cb=>(tokenHandler=cb,!0))(cb)},request:req=>request({method:req.method||null,path:req.path||parsedPath,data:req.data||null,token:req.token||null}),put:data=>((path,data)=>request({method:"put",path:path,data:data}))(parsedPath,data),get:query=>((path,query)=>request({method:"get",path:path,data:query}))(parsedPath,query),del:()=>(path=>request({method:"del",path:path}))(parsedPath),list:query=>((path,data)=>request({method:"list",path:path,data:data}))(parsedPath,query),parse:(path=null)=>ParsePath((path||parsedPath).toString()),path:path=>{path||(path="/");let slash="";return"/"!==parsedPath&&(slash="/"),Channel(parsedPath+slash+path)}}};return Channel("/")},starbase.Socket=function(server){let stateHandler,messageHandler,errorHandler,ws=null,closed=!1;const ERROR=e=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(e),console.error(e)},stateChange=state=>{stateHandler&&"function"==typeof stateHandler&&stateHandler(state)},onopen=e=>{stateChange("connected"),closed=!1},onclose=e=>{stateChange("disconnected"),closed||ERROR("disconnected.")},onmessage=msg=>{if(messageHandler&&"function"==typeof messageHandler)try{msg=JSON.parse(msg.data),messageHandler(msg)}catch(e){}},onerror=err=>{errorHandler&&"function"==typeof errorHandler&&errorHandler(err)};let socket={getState:()=>!(!ws||1!==ws.readyState)};return socket.connect=socket.open=(()=>{ws&&1===ws.readyState?ERROR("Already connected."):server?((ws=new WebSocket(server)).onopen=onopen,ws.onmessage=onmessage,ws.onclose=onclose,ws.onerror=onerror):ERROR("No server provided.")}),socket.send=(message=>{ws&&1===ws.readyState?ws.send(JSON.stringify(message),err=>{err?ERROR(err.toString()):console.log("Message Sent")}):ERROR("Not Connected")}),socket.close=(()=>{closed=!0,ws&&1===ws.readyState?ws.close():ERROR("Not Connected")}),socket.onMessage=(handler=>{messageHandler=handler}),socket.onState=(cb=>{stateHandler=cb}),socket.onError=(cb=>{errorHandler=cb}),socket.setServer=(socketURL=>{server=socketURL}),socket},starbase.theRules=theRules,starbase.Auth=function(api=null,localDB=null,options={}){if(options&&"object"==typeof options||(options={}),!api)throw"Starbase Channels API Client is missing.";if(!localDB)throw"Starbase Channels Database is missing.";let db=localDB,request=(method,credentials)=>api.path("/").request({method:method,data:credentials}),tokenPath=(options.parentChannel||"/auth/token").toString(),stateHandler=null,authToken=null,user=null,stateChange=async token=>{token||(token=null),authToken=token,db&&await db.path(tokenPath).put({token:authToken}),authToken&&authToken.user?(user=authToken.user,auth.user=user):(user=null,auth.user=user),stateHandler&&"function"==typeof stateHandler&&stateHandler(authToken)},auth={user:null,getToken:()=>(async()=>new Promise(async(resolve,reject)=>{if(!authToken&&db){let storedToken=await db.path(tokenPath).get().then(result=>result.data).catch(err=>null);storedToken&&storedToken.token&&(authToken=storedToken.token,stateChange(authToken))}return authToken?authToken.accessExpires<Date.now()?authToken.refreshExpires>Date.now()?void request("refreshToken",authToken).then(result=>(stateChange(result),resolve(result.accessToken))).catch(err=>(stateChange(null),reject(err))):(stateChange(null),reject({code:400,message:"Invalid or expired token."})):resolve(authToken.accessToken):resolve(null)}))(),onStateChange:cb=>{stateHandler=cb},createUser:(username,password)=>new Promise((resolve,reject)=>{request("createUser",{username:username,password:password}).then(resolve).catch(reject)}),deleteUser:(username,password)=>new Promise((resolve,reject)=>{request("deleteUser",{username:username,password:password}).then(resolve).catch(reject)}),changePassword:(username,password,newPassword)=>new Promise((resolve,reject)=>{request("changePassword",{username:username,password:password,newPassword:newPassword}).then(resolve).catch(reject)}),signIn:(username,password)=>new Promise((resolve,reject)=>{request("signIn",{username:username,password:password}).then(token=>{stateChange(token),resolve(token)}).catch(err=>{reject(err)})}),signOut:()=>new Promise((resolve,reject)=>{stateChange(null),resolve({message:"Signed out."})})};return db&&auth.getToken().catch(err=>{}),auth},starbase.Admin=function(api,auth){if(!api)throw"Starbase Channels API Client object is missing.";if(!auth)throw"Starbase Authentication object is missing.";return api.setTokenHandler(auth.getToken),api},starbase.Profiles=function(api=null,auth=null){if(!api)throw"The Starbase Channels API client is missing";if(!auth)throw"The Starbase Authentication client is missing";return{getProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).get()},deleteProfile:async function(username){return api.setToken(await auth.getToken()),api.path(username).del()},updateProfile:async function(username,profile){return api.setToken(await auth.getToken()),api.path(username).put(profile)},listProfiles:async function(query={}){return query&&"object"==typeof query||((query={}).limit=10),(!query.limit||query.limit>10)&&(query.limit=10),api.setToken(await auth.getToken()),api.list(query)},auth:auth}},starbase.PWA=function(){return{app:(swURL,onInstallReady)=>{navigator.serviceWorker.register(swURL);const getServiceWorker=async()=>await navigator.serviceWorker.getRegistration();return window.addEventListener("beforeinstallprompt",function(e){onInstallReady&&"function"==typeof onInstallReady&&onInstallReady(async cb=>{e.prompt(),e.userChoice.then(result=>{cb&&"function"==typeof cb&&cb(result)})})}),{getServiceWorker:getServiceWorker,RESET:async()=>{(await getServiceWorker()).unregister().then(()=>{location.reload()})}}},sw:(resources=[],offlineURL=null)=>(offlineURL&&!resources.includes(offlineURL)&&resources.push(offlineURL),self.addEventListener("install",async e=>{console.log("Installing Service Worker..."),await caches.delete("resources");let cache=await caches.open("resources");return await cache.addAll(resources),self.skipWaiting()}),self.addEventListener("activate",async e=>{console.log("Service Worker Activated!")}),self.addEventListener("fetch",e=>{if("GET"!==e.request.method)return null;e.respondWith(fetch(e.request).then(async response=>{if(!response)return offlineURL?caches.match(offlineURL):null;if(response.status>499){let cached=await caches.match(e.request);if(cached)return cached;if(offlineURL)return caches.match(offlineURL)}return(await caches.open("resources")).put(e.request,response.clone()),response}).catch(async err=>await caches.match(e.request)||(offlineURL?caches.match(offlineURL):void 0)))}),{})}},starbase.Cryptic=Cryptic,starbase.CryptoDB=CryptoDB,starbase.Encryption=Encryption,starbase}